{"title":"The **[R]{.sans-serif}** *Environment*","markdown":{"headingText":"The **[R]{.sans-serif}** *Environment*","containsRefs":false,"markdown":"\n**[R]{.sans-serif}** has been described as \"an environment for\nstatistical modeling and graphics.\\\" The word *environment* instead of\n*package* is one of the main reasons **[R]{.sans-serif}** is distinct\nfrom other statistical programs. A *package* gives a user a fixed set of\ntools. An *environment*, in addition to providing a fixed set of tools,\nallows users to customize those existing tools and to develop their own\ntools to suit their unique needs.\n\n## Why Are There So Many Use**[R]{.sans-serif}**s?\n\nThese are some of the likely reasons you are here today.\n\n### Statistical Tools\n\nThe **[R]{.sans-serif}** environment contains many powerful tools for\nstatistical analysis including\n\n-   Linear and Generalized Linear Models\n\n-   Survival Analysis\n\n-   Random and Mixed Effects Models\n\n-   Classification and Clustering\n\n-   Sample Size and Power Calculations\n\n-   Multivariable analysis (FA, PCA, SEM, ...)\n\nIn this workshop will see and use sample code for many of these\nanalyses.\n\n### Graphics\n\nMany researchers use **[R]{.sans-serif}** specifically for its excellent\ngraphing capabilities. Graphics in **[R]{.sans-serif}** are easy to\nimplement and modify. Once you are comfortable with\n**[R]{.sans-serif}**, you will have several powerful graphics packages\nat your fingertips. \"Base graphics\" has been supplemented by \"grid\ngraphics\" and the \"grammar of graphics.\"\n\n### Extensibility\n\nDespite the extensive built-in statistical techniques, the most powerful\nfeature of **[R]{.sans-serif}** is the ability for users to extend\n**[R]{.sans-serif}**'s base capabilities. **[R]{.sans-serif}** is a\nfull-fledged programming language that allows users to write their own\nfunctions. Users can contribute their own \"packages\" that build on\n**[R]{.sans-serif}**'s base capabilities. Users have contributed over\n13,700 packages to CRAN (Comprehensive **[R]{.sans-serif}** Archive\nNetwork) as of March 2019.\n\n### Cost (\\$0)\n\n**[R]{.sans-serif}** is open source: the source code behind the software\nis free for all to examine and extend. **[R]{.sans-serif}** grows by\nleaps and bounds as people from all fields develop new functions for use\nwithin **[R]{.sans-serif}**'s computing environment. This is part of\nwhat makes **[R]{.sans-serif}** so useful. Many complex statistical\nroutines that not yet available in other statistical software systems\nhave been programmed in **[R]{.sans-serif}**, and these routines are\nfreely available for use by anyone.\n\n### Operating Systems and GUIs\n\n**[R]{.sans-serif}** runs on Windows, MacOS, and a variety of Unix\nplatforms. In Windows, there are at least four GUIs: the standard\n**[R]{.sans-serif}** GUI, **[R]{.sans-serif}**Studio,\nTinn-**[R]{.sans-serif}**, and **[R]{.sans-serif}** Commander. We will\nbe using the standard **[R]{.sans-serif}** GUI some and\n**[R]{.sans-serif}**Studio (`www.rstudio.com`) more. It organizes the\nuser's screen into panes that display programs/scripts, objects,\ngraphics, and the **[R]{.sans-serif}** console. **[R]{.sans-serif}**\nCommander (`www.rcommander.com`), developed by John Fox at McMaster\nUniversity, is a front-end for interacting with **[R]{.sans-serif}**\nthrough menus. This package can be useful to **[R]{.sans-serif}**\nbeginners. It provides helpful tools for getting started and then\ndisplays the underlying **[R]{.sans-serif}** code for each analysis to\nhelp the user learn the programming language. Tinn-**[R]{.sans-serif}**\n(`sourceforge.net/projects/tinn-r/`) is another enhanced editor from\nJose Claudio Faria.\n\n### Reproducible Research\n\n**[R]{.sans-serif}** has several methods for integrating code, output,\nand interpretation into a single document. This allows consumers to\nconfirm the original analysis and to investigate other approaches.\n\n## Why Isn't Everyone a Use**[R]{.sans-serif}**?\n\n### One and Only\n\nMany users of statistics learn only one package: the one taught in their\nfirst introductory statistics course. Historically this has rarely been\n**[R]{.sans-serif}**, but there are signs this is changing.\n\n### Steep Learning Curve\n\nIt can take time to get comfortable and productive with\n**[R]{.sans-serif}**. A user often interacts with **[R]{.sans-serif}**\nthrough typed commands, rather than via a point-and-click menu system.\nFor users with minimal background writing code, it can take some time to\nget the hang of using **[R]{.sans-serif}**. Furthermore, while the help\nsystem is comprehensive for the base packages, it's quality ranges for\ncommunity-written packages. Don't get frustrated! You don't have to be\nan expert programmer to learn **[R]{.sans-serif}**. The benefits\n(flexibility, extensibility, speed) are worth spending some time up\nfront.\n\n## Suggestions for Learning **[R]{.sans-serif}**\n\n-   Learn interactively! Reading can help only so much. Most people\n    learn **[R]{.sans-serif}** best by typing commands themselves.\n\n-   Ask questions of current **[R]{.sans-serif}** users, e.g., your\n    instructor.\n\n-   Look at (and retype) lots of sample code. Experiment with\n    modifications of the code. You won't break **[R]{.sans-serif}**.\n    You'll see many examples in this workshop but there is much more\n    online.\n\n-   Don't worry about getting errors. Experienced **[R]{.sans-serif}**\n    users make errors all the time. Base **[R]{.sans-serif}** has\n    excellent error messages that are good learning opportunities\n    themselves.\n\n    -   `www.r-project.org`: The **[R]{.sans-serif}** Home page, the\n        central webpage for the **[R]{.sans-serif}** project. Here you\n        will find links for downloading **[R]{.sans-serif}**,\n        downloading additional packages for **[R]{.sans-serif}**, and\n        almost everything else that you would like to know about the\n        software or the people behind it.\n\n    -   `cran.r-project.org/web/views/`: Task views summarize the most\n        important packages involved in a subject field or analysis type.\n\n    -   `journal.r-project.org`: The **[R]{.sans-serif}** Journal\n\n    -   `stats.stackexchange.com`: Cross-Validated\n\n    -   `www.r-bloggers.com`\n\n    -   `stats.idre.ucla.edu/r/`: Institute for Digital Research and\n        Education at UCLA\n\n    -   `socialsciences.mcmaster.ca/jfox/`: John Fox's home page\n\n    -   `sas-and-r.blogspot.com/`: Examples of code to perform same task\n        in each language\n\n## How To Obtain **[R]{.sans-serif}**\n\n**[R]{.sans-serif}** is already installed on the lab workstations. The\nfollowing information is useful if you need to install\n**[R]{.sans-serif}** on another machine.\n\nAt the **[R]{.sans-serif}** Project Web Page (`www.r-project.org`) the\nmost important link is at the left hand side of the screen, under the\n\"Download\" heading. Click on the CRAN link (Comprehensive\n**[R]{.sans-serif}** Archive Network), and, after you choose one of the\nU.S. mirrors, you will be taken to the page that you will use to\ndownload everything **[R]{.sans-serif}**-related.\n\nOnce you find the CRAN web page, take the following steps to obtain\n**[R]{.sans-serif}**:\n\n1.  Click on \"Download **[R]{.sans-serif}** for XXX\" that best describes\n    your operating system (Linux, OS X, Windows).\n\n2.  When using Windows, click on the \"base\" subdirectory. This will\n    allow you to download the base **[R]{.sans-serif}** packages.\n\n3.  Click the \"Download **[R]{.sans-serif}** 3.X.X for Windows\" link.\n    **[R]{.sans-serif}** is updated quite frequently. At the time of\n    this printing, version 3.5.2 is available. Save the .exe file\n    somewhere on your computer.\n\n4.  Double-click on the .exe file once it has been downloaded. A wizard\n    will appear that will guide you through the setup of the\n    **[R]{.sans-serif}** software on your machine.\n\n5.  Once you are finished, you should have an **[R]{.sans-serif}** icon\n    on your desktop that gives you a shortcut to the\n    **[R]{.sans-serif}** system. Double-click on this icon, and you are\n    ready to go!\n\n### How to Obtain RStudio\n\n**[R]{.sans-serif}**Studio is already installed on the lab workstations.\nThe following information is useful if you need to install\n**[R]{.sans-serif}**Studio on another machine.\n\nVisit (`www.rstudio.com`) and download the free desktop version of\n**[R]{.sans-serif}**Studio.\n\n### Contributed Packages\n\nWhat exactly are \"additional contributed packages\"? **[R]{.sans-serif}**\nis an open source software environment, so users are free to explore the\ncode behind the software and to write their own new code. Statisticians,\nresearchers, and other users have written additional packages for\n**[R]{.sans-serif}** that perform complex analyses (and simple ones!).\nIn order to use these packages and the functions within them, you first\nneed to download them. Base **[R]{.sans-serif}** comprises many\npackages, but odds are that you will discover an uncommon analysis\ntechnique in your research that requires you to install an additional\npackage that is not included by default.\n\nThese additional packages are usually found CRAN. However, there are\nother repositories as well (e.g., bioconductor, github).\n\n# Getting Started with **[R]{.sans-serif}**\n\nLaunch **[R]{.sans-serif}** from the Start Menu or the desktop icon.\n(We'll shift to **[R]{.sans-serif}**Studio after we have some\nfamiliarity with using **[R]{.sans-serif}** interactively.)\n\n## Using **[R]{.sans-serif}** as a Calculator\n\n**[R]{.sans-serif}** can perform basic arithmetic operations. Type the\nfollowing expressions at the command prompt in the **[R]{.sans-serif}**\nconsole window.\n\n`> 5+3`\n\n`> 5-3`\n\n`> 5/3`\n\n`> 5*3`\n\n`> 5^3`\n\n`> 4 + 2 * 3`\n\n`> (4 + 2) * 3`\n\nIf you have missing input (represented in **[R]{.sans-serif}** by NA),\nthe output will likely be missing:\n\n`> (4 + NA) * 3`\n\nIf you try something mathematically shoddy, you will likely be told:\n\n`> 0 / 0`\n\n`> 1 / 0`\n\n`> -1 / 0`\n\n**[R]{.sans-serif}** has many built-in mathematical functions.\n\n`> log(100)`\n\n`> sqrt(9)`\n\n`> sqrt(-9)`\n\n`> sqrt(-9 + 0i)`\n\nThis is your first indication that an **[R]{.sans-serif}** function may\nbehave differently depending on the *type* of input.\n\n`> sqrt(NA)`\n\n`> exp(1)`\n\nAn *argument* is a parameter that is passed to a function. The `sqrt`\nand `exp` functions only take a single argument. Many functions,\nincluding `log`, take more than one argument. Arguments are separated by\ncommas.\n\n`> round(5.123, 2)`\n\nIf not all arguments are provided, **[R]{.sans-serif}** may use a\ndefault value.\n\n`> round(5.123)`\n\nSome other basic functions:\n\n`> ceiling(5.123)`\n\n`> floor(5.123)`\n\nThe \"Remainder\" and Integer Division operations:\n\n`> 17 %% 5`\n\n`> 17 %/% 5`\n\n**Review of logarithms** If $a^y = x$, then $\\log_a(x) = y$. For\nexample, $10^2 = 100$ and $\\log_{10}(100) = 2$. Three common choices of\nthe base are $10$, $2$, and $e$. What is the default choice in\n**[R]{.sans-serif}**?\n\n`> log(10)`\n\n`> log(2)`\n\n`> log(exp(1))`\n\nSuppose you are working with a dataset and you wish to apply the\n$\\log_{10}$ transformation. How can we instruct **[R]{.sans-serif}** to\ntake logarithms base 10? **[R]{.sans-serif}**'s help pages are good\nsources of information for questions such as these. Two ways to view a\nfunction's help page are '?' and 'help'. A more generic approach might\nbe searching \"take log in r\" with your favorite search engine.\n\n`> ?log`\n\n`> help(log)`\n\nThe `log` function can take two arguments including the *base* argument.\nArguments can be specified in several ways.\n\nThe argument name can be stated explicitly:\n\n`> log(x=25, base=5)`\n\nThe argument name can be abbreviated as long as the abbreviation is\nunique:\n\n`> log(x=25, b=5)`\n\nNot all arguments need to be named:\n\n`> log(25, b=5)`\n\n`> log(b=5, 25)`\n\nWe don't have to use the argument names at all, in which case the\narguments are matched by the order listed. Compare\n\n`> log(25, 5)`\n\n`> log(5, 25)`\n\n**[R]{.sans-serif}** may return an error if you incorrectly name a\nfunction argument.\n\n`> log(25, be=5)`\n\n## Making Comparisons: Logical Operators\n\n**[R]{.sans-serif}** has logical operators that will return \"TRUE\" or\n\"FALSE\" (or possibly \"NA\" if you have missing values).\n\n`> 5 == 6`\n\n`> 5 != 6`\n\n`> 5 < 6`\n\n`> 5 > 6`\n\n`> 5 <= 6`\n\n`> 5 <= NA`\n\n`> 5 <= Inf`\n\n`> !TRUE`\n\n`> (1 + 2) == 3`\n\n**[R]{.sans-serif}** has \"and\" and \"or\" operators (there are others):\n\n`> (5 < 6) & (7 == 8)`\n\n`> (5 < 6) | (7 == 8)`\n\n`> (5 < 6) | NA`\n\n**Be careful of comparisons and floating point arithmetic**:\n\n`> (.1 + .2) == .3`\n\n`> 5 == sqrt(5)^2`\n\n`> 5 - sqrt(5)^2`\n\nThe `all.equal` function will test if two values are \"close enough\":\n\n`> all.equal(5, sqrt(5)^2)`\n\n`> ?all.equal`\n\nThis is not bug of **[R]{.sans-serif}**. It is a feature of computers\nusing binary representation of floating point numbers and storing them\nwith finite precision. This is common enough to make the\n**[R]{.sans-serif}** FAQ (7.31):\n`https://cran.r-project.org/doc/FAQ/R-FAQ.html`. To quote from \"The\nElements of Programming Style\" by Kernighan and Plauger: \"10.0 times 0.1\nis hardly ever 1.0.\"\n\n## Vectors and Sequences\n\n**[R]{.sans-serif}** is a 'vectorized' language. Many functions operate\non an entire vector of numbers as easily as on a single number. This\nfeature allows the user to think in terms of manipulating entire data\nvariables rather than one data element at a time. For example (once we\nhave learned about storing objects), we can write `mean(Height)` or\n`hist(Height)` to analyze a variable, rather than working with the\nindividual data values.\n\nThus it is important to be able to create and manipulate vectors.\nNumbers can be combined into a vector with the function 'c', which\nstands for *combine*.\n\n`> c(3, 9, 2)`\n\nThe following commands produce exactly the same output, namely a vector\nwith the integers 1 to 10. In **[R]{.sans-serif}**, there are often many\nways of doing the same thing.\n\n`> c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)`\n\n`> 1:10`\n\n`> seq(1, 10, 1)`\n\n`> seq_len(10)`\n\n`> ?seq`\n\nYou can specify a sequence's increment or length using the *by* and\n*length* arguments.\n\n`> seq(0, 200, by=4)`\n\n`> seq(0, 200, length=13)`\n\n`> rep(3, 12)`\n\nIn **[R]{.sans-serif}**, functions can be nested. In the following\nexamples, the inner function, `c`, is used to create a vector and the\nouter function uses that vector as an argument.\n\n`> rep(c(3,9,2), times=4)`\n\n`> rep(c(3,9,2), each=4)`\n\n`> rep(c(3,9,2), length=12)`\n\n`> rep(c(3,9,2), times=c(2,9,1))`\n\n## Matrices and Arrays\n\nIn **[R]{.sans-serif}**, a matrix or an array is just a vector with a\ndimension *attribute*. The `matrix` command can rearrange a vector into\na matrix.\n\n`> matrix(1:12, nrow=3)`\n\nWhat happens if we don't specify the number of rows using the argument\n`nrow`?\n\n`> matrix(1:12)`\n\nThe result is still a matrix, but the default is to put each element in\na separate row. What happens if we specify an inappropriate number of\nrows?\n\n`> matrix(1:12, nrow=5)`\n\nWhen the number of rows and the number of elements are not coherent,\n**[R]{.sans-serif}** issues a warning.\n\nA vector has 1 dimension; a matrix has 2 dimensions; an array can have\nany number of dimensions. These have 3 dimensions:\n\n`> array(1:12, dim=c(2,2,3))`\n\n`> array(1:12, dim=c(2,3,2))`\n\n# Using Scripts\n\nUntil now, we have submitted each command to **[R]{.sans-serif}** by\ntyping directly at the command prompt. In almost all situations, it is\n**much** better to type code in a separate file called a script file.\nThere are many advantages of using script files.\n\n-   Repeatability\n\n-   Editing\n\n-   Submitting many commands at once\n\n## Scripts in **[R]{.sans-serif}** GUI\n\nTo open an **[R]{.sans-serif}** script, go to File `->` New Script. You\ncan type your commands in the resulting windows. It is useful to save\nyour script files with a .R extension. Then the operating system\nrecognizes this as an **[R]{.sans-serif}** file.\n\nAfter opening a new script, type\n\n`> history()`\n\nA new window will open with the last 25 commands you have used. You can\nget a longer history with, say,\n\n`> history(100)`\n\nSelect all your commands and copy-paste them to the new script. Save the\nfile with a .R extension.\n\nThere are several ways of submitting commands from the\n**[R]{.sans-serif}** script window.\n\n-   Copy and Paste from the script window to the interpreter window\n\n-   Control-r\n\n-   The `source` command. If your file is saved as *myfile.R*, you can\n    run all the commands in the file by typing the following line at the\n    command prompt.\n\n    `> source(\"myfile.R\")`\n\n    In order for **[R]{.sans-serif}** to read your script, you must use\n    the full path or be in the correct working directory. To change the\n    current working directory, go to File `->` Change Dir, then browse\n    to the appropriate folder.\n\n    To see the files in the current working directory, type:\n\n    `> dir()`\n\n    Another possibility is to find the file using\n\n    `> source(file.choose())`\n\n    but this does not change the working directory.\n\n## Comments\n\nDocumentation and formatting are essential to writing effective\n**[R]{.sans-serif}** code. If you come back to a project after a few\nmonths (days? hours?), you want to know what the code is doing without\nretracing every single step. Comments in **[R]{.sans-serif}** can be\ninserted with the `#` symbol. **[R]{.sans-serif}** will not process the\nrest of the line after the `#`.\n\n`> 5 < 6`\n\n`> 5 # < 6`\n\nThe following is an example of a commented **[R]{.sans-serif}** script.\nSome of the functions we have used before; others will be explained\nlater. Let's open it in **[R]{.sans-serif}**Studio and see what it does.\n\n## **[R]{.sans-serif}**Studio\n\n**[R]{.sans-serif}**Studio is an interface to **[R]{.sans-serif}**. It\norganizes the user's screen into windows that display programs\n(scripts), objects, graphics, and the **[R]{.sans-serif}** interpreter.\nLaunch **[R]{.sans-serif}**Studio from the start menu. Click on the\nfolder in the upper left corner and browse to the folder containing the\nscript \"sample script.R\". The following should open in the upper left\nwindow.\n\n## Sample Script\n\n\\# sample script.R\n\n\\# Chris Andrews\n\n\\# Created 2015 04 01\n\n\\# Last Modified 2019 02 03\n\n\\# This script analyzes the Life Cycle Savings data.\n\n\\# See help(LifeCycleSavings) for more details.\n\n\\#\n\n\\# Shorten the name and make local copy\n\nLife = LifeCycleSavings\n\n\\# Examine Structure\n\nhead(Life)\n\ndim(Life)\n\nstr(Life)\n\n\\# Descriptives\n\nsummary(Life)\n\n\\# Pairwise associations\n\ncor(Life)\n\npairs(Life)\n\n\\# Fit a multiple regression model\n\nmr.mod = lm(sr   pop15 + pop75 + dpi + ddpi, data=Life)\n\nsummary(mr.mod)\n\nanova(mr.mod)\n\n\\# Plot the fit\n\npar(mfrow=c(2,2), las=1, mar=c(4.5,4.5,2,1))\n\nplot(mr.mod)\n\nUse \"Ctrl-Enter\" to submit each line of the script. Take note of what\nhappens as each line is submitted to the interpreter.\n\n# Objects\n\n## Assignment\n\nAn *object* is an entity that contains information and can be\nmanipulated by commands. **[R]{.sans-serif}** has two main commands for\nassigning an object: '$<$- ' and '='.\n\n`> x <- 5`\n\n`> x = 5`\n\nWe will use '=' throughout this document. However, many\n**[R]{.sans-serif}** users prefer '`<-`', because '=' is used for other\nthings, too. A third method is very rarely used:\n\n`> 5 -> x`\n\nEach of the previous commands assigns the number `5` to the object `x`.\nNotice that **[R]{.sans-serif}** produces no output when the above\ncommands are run. In order to see what **[R]{.sans-serif}** has done,\ntype:\n\n`> ls()`\n\nand/or look at the environment window in the upper right corner. Now\ntype\n\n`> x`\n\nWhen you submit a command to **[R]{.sans-serif}**, one of three things\ncan happen.\n\n1.  You see a result: e.g.,\n\n    `> x`\n\n    **[R]{.sans-serif}** prints the value of the expression.\n\n2.  You see nothing except another command prompt: e.g.,\n\n    `> y = log(x)`\n\n    For an assignment, **[R]{.sans-serif}** stores the value of `log(x)`\n    in the object `y`, but produces no output.\n\n3.  You see an error message: e.g.,\n\n    `> y = lg(x)`\n\n    Look at error messages -- they can be informative!\n\n## Manipulating Objects\n\nWe can perform mathematical operations on objects such as `x`.\n\n`> x + 2`\n\nNotice that x has not changed:\n\n`> x`\n\nWe can change the value of x:\n\n`> x = x + 2`\n\n`> x`\n\n*Cautionary Tip*: It is very important to use caution when writing over\na variable as above. If you need to use `x` later on, be sure you are\nusing the correct value!\n\nStart from scratch and perform operations on two objects.\n\n`> x = 5`\n\n`> y = 2`\n\n`> x - y`\n\nIf two objects are assigned to have the same value, they can be changed\nto differ. (Assigned by value not by assigned by reference, for those of\nyou who know what that means.)\n\n`> a = 3`\n\n`> b = a  # Note: Assignment`\n\n`> b == a # Note: Test of Equality`\n\n`> a = a + 1`\n\n`> a`\n\nThe value of `b` didn't change.\n\n`> b`\n\nAssign a vector of numbers to the object `x`\n\n`> x = c(3, 5, 9, 10)`\n\n`> x`\n\nGet a list of the objects in the workspace.\n\n`> ls()`\n\nRemove an object.\n\n`> rm(x)`\n\n## Indexing Objects\n\nSituations frequently arise when you want to access select portions of a\ndatabase. In this section, we discuss how to extract elements of vectors\nand matrices.\n\n### Indexing Vectors\n\n`> x = c(13,21,99,10,0,-6)`\n\nSuppose that we only need the first element of the vector `x`. To\nextract the first element, we type the name of the entire vector,\nfollowed by the index we want to extract enclosed in brackets.\n\n`> x[1]`\n\nWe can save the extracted part to a new object\n\n`> z = x[1]`\n\n`> z`\n\nWe often will want to extract more than one element of a vector. Each of\nthe following two lines of code extracts the first three elements of the\nvector `x`.\n\n`> x[c(1,2,3)]`\n\n`> x[1:3]`\n\nWhat happens if we try to extract the first three elements in the\nfollowing way?\n\n`> x[1,2,3]`\n\nElements can be extracted in any order and elements can be extracted any\nnumber of times. All of the following are legitimate methods of\nextracting multiple elements from a vector.\n\n`> x[c(2,4,5)]`\n\n`> x[c(4,5,1)]`\n\n`> x[c(5,1,5,2,1,1,1,5)]`\n\nThe following code extracts all elements of x *except* the second.\n\n`> x[-2]`\n\nWhat will this do?\n\n`> x[-c(2,4)]`\n\n### Indexing Matrices\n\nTo extract an element from a matrix, you may specify two values: the row\nvalue and the column value. The row and column are separated by a\ncolumn.\n\n`> M1 = matrix(1:12, nrow=3, byrow=TRUE)` \\# (this is obj5 from before,\nso M1 = obj5 works too)\n\n`> M1`\n\nPick out the number from the second row and third column.\n\n`> M1[2,3]`\n\nYou can simultaneously select multiple rows and multiple columns.\n\n`> M1[2,c(1,3)]`\n\n`> M1[c(2,3),c(1,2)]`\n\nIf nothing is specified in the row position (before the comma), then\nevery row is kept. Similarly, every column is kept if nothing is\nspecified in the column position.\n\n`> M1[,c(2,3)]`\n\n`> M1[c(1,2),]`\n\nIf nothing is specified in either position, the entire matrix is\nreturned.\n\n## Index Assignment\n\nIn addition to extracting certain indices, it is also possible to\n*assign* new values to certain elements of a vector or matrix.\n\nThe following two lines of code change an element of the vector `x` and\nthe matrix `M1`.\n\n`> x[3] = 5`\n\n`> M1[2,3] = 6`\n\n## Aside: Missing Index?\n\nIf an index is missing, it might be any index. This is rarely what you\nwant: Avoid missing values in your index.\n\n`> x[NA]`\n\n## Object Classes\n\nSo far we seem to have been working exclusively with numeric objects.\n**[R]{.sans-serif}** can store objects of many different types. Suppose\nyou are working with a data set that includes both quantitative and\ncategorical variables. **[R]{.sans-serif}** can store these as different\nclasses. Let's begin by looking at two basic classes, `numeric` and\n`character`.\n\n`> x = 12`\n\n`> class(x)`\n\n`> y = c(3,5,2)`\n\n`> class(y)`\n\n**[R]{.sans-serif}** stores both the number `12` and the vector\n`c(3,5,2)` as an object of the class *numeric*. Strings are stored as\n*characters*.\n\n`> x = \"Hi\"`\n\n`> class(x)`\n\n`> y = c(\"sample\", \"string\")`\n\n`> class(y)`\n\nElements of vectors and matrices must be of the same class.\n\n`> mix = c(\"aa\", -2)`\n\n`> mix`\n\n`> class(mix)`\n\n`> mix[2]`\n\n`> class(mix[2])`\n\nWhen working with data, this will create problems if a column\nrepresenting a quantitative variable contains character text. The\nnumeric is *promoted* to character.\n\n## How to Mix Variables of Different Classes\n\nMatrices are not well-suited for storing data sets. Data sets frequently\ncontain different types of variables (quantitative, qualitative).\nMatrices force all elements to be of the same class. A `data.frame` is\nparticularly adept at handling data of different classes.\n\n`> num = c(2,9,6,5)`\n\n`> char = LETTERS[c(24,24:26)]`\n\n`> dat = data.frame(num, char, stringsAsFactors=FALSE)`\n\n`> dat`\n\n`> class(dat)`\n\nThough data analysts will rarely spend their time investigating a data\nset as small this one, exploring data sets such as these can be helpful\nin learning **[R]{.sans-serif}**'s capabilities. In the following code,\nwe investigate the names and dimensions of the data set `dat`; we also\ninvestigate the properties of the columns of `dat`.\n\n`> names(dat)`\n\n`> dim(dat)`\n\n`> nrow(dat)`\n\n`> ncol(dat)`\n\n`> class(dat[,1])`\n\n`> class(dat[,2])`\n\n**[R]{.sans-serif}** stores the first column as *numeric* and the second\ncolumn as a *character*. `summary` gives a numerical summary of numeric\nvariables and little useful information for character variables.\n\n`> summary(dat)`\n\nIt is likely that you want to store a categorical variable as a *factor*\nrather than a character vector. The default behavior of data.frame to do\nthe conversion.\n\n`> dat = data.frame(num, fac=char)`\n\nNow **[R]{.sans-serif}** stores the first column as *numeric* and the\nsecond column as a *factor*. `summary` gives a numerical summary of\nnumeric variables and a table for categorical variables.\n\n`> class(dat[,2])`\n\n`> summary(dat)`\n\nKeeping track of column numbers can be tedious. It is often more\nconvenient and cleaner to index by the column name. Name indexing uses\nthe dollar sign (`$`) or double square braces (`[[]]`).\n\n`> dat$num # Or dat[[\"num\"]]`\n\n`> dat$fac # Or dat[[\"fac\"]]`\n\nFactors can be created explicitly (not just as a side effect of the\n`data.frame` function)\n\n`> fac = factor(char)`\n\nThe `levels` function returns the levels of a factor.\n\n`> levels(fac)`\n\n# Data for Analysis\n\n## Creating Data: Random numbers\n\n**[R]{.sans-serif}** has excellent number generating capabilities. This\nmakes **[R]{.sans-serif}** a good programming environment for simulation\nstudies. The `rnorm` function randomly draws from a univariate normal\ndistribution. (The 'r' stands for random.)\n\n`> rnorm(3)`\n\n`> rnorm(3, mean=10, sd=0.5)`\n\n`> x = rnorm(100, mean=10, sd=2)`\n\n`> hist(x, col=\"blue\", main=\"100 Random Numbers from a Normal Distribution\")`\n\nSee `help(rnorm)` for more details. You can generate from many\ndistributions using functions such as `rnorm`, `rt`, `rf`, `rbinom`,\n`runif`, `rexp`, and `rgamma`.\n\n### Functions about Probability Distributions\n\n**[R]{.sans-serif}** is also a source of exact probability tables and\ntherefore eliminates the need to flip to the back of a statistics\ntextbook to calculate probabilities under curves or critical values. For\nexample, you can calculate the 95% critical value of a t distribution\nwith 34 degrees of freedom with the following command:\n\n`> qt(0.975, df=34)`\n\nWe can find the critical value of a standard normal distribution using\n`qnorm`. (The 'q' stands for quantile function.)\n\n`> qnorm(0.975)`\n\nWe can also find cumulative probabilities needed for p-values. (The 'p'\nstands for probability function.)\n\n`> pnorm(-1.96)`\n\n## Reading data from files\n\nResearchers often analyze data that are stored in spread-sheet or text\nformats. The most common function to import data is `read.table`. Before\nlooking at an example of how `read.table` is used, let's consider common\nissues that arise when reading data into any program.\n\n-   What is the file name?\n\n-   What is the file type?\n\n-   Where is the file located?\n\n-   Does the file include variable names?\n\n-   How are fields separated (e.g., tab, comma, white-space)?\n\n-   How are missing values stored?\n\nThe `read.table` function is used in **[R]{.sans-serif}** for importing\ntext data into data set objects. This function requires that you have a\nvalid data table in a text format (where rows are observations, and\ncolumns are variables) with every cell containing a data point. If there\nare any blanks, the function may not work properly. Missing values by\ndefault should be coded as NA before attempting to import text data.\nColumns should be separated by white space.\n\nThe `read.table` function has arguments that allow the user to control\ndata importation features.\n\n`> help(read.table)`\n\nThe four most important arguments to the `read.table` function are\n*file*, *header*, *sep*, and *na.strings*. Let's practice by importing\nthe *samp2.dat* text file. Be sure to first change the working directory\nto the folder that contains *samp2.dat*. In **[R]{.sans-serif}**Studio\nyou can either use the Session \\> Set Working Directory menu option or\nuse the `setwd()` function.\n\n`> gro = read.table(\"groceries.txt\")`\n\n`> head(gro)`\n\n`> str(gro)`\n\nBy passing only the *file* argument to `read.table`, we have left all\nother arguments at their default values. Notice that\n**[R]{.sans-serif}** reads the variable names to be the first row of\ndata rather than the column names. **[R]{.sans-serif}** has stored the\ncolumns of *gro* as a factor.\n\n`> gro = read.table(\"groceries.txt\", header=TRUE)`\n\n`> head(gro)`\n\n`> str(gro)`\n\n`> tail(gro)`\n\n`> summary(gro)`\n\n`> dim(gro)`\n\n## Importing from Excel\n\n\"How do I import my data into **[R]{.sans-serif}** from Excel?\" is a\ncommon question.\n\nMy answer is often: \"Don't!\"\n\nExcel spreadsheets contain attributes and formatting that often cause\ndifficulty when transferring files between applications. In particular,\ndates, or text that looks like dates, are troublesome. Zip codes and\nMRNs lose their leading zeros. The easiest thing to do is to first\nexport the data into either a tab-delimited (.dat, .tsv) or comma\nseparated values (.csv) file. After the file is in a more portable\nformat, then use `read.table` or `read.csv` into **[R]{.sans-serif}**.\n\nWe use the *samp2.csv* file for practice.\n\n`> dat2 = read.csv(\"samp2.csv\", na.strings=c(NA, 88, 999))`\n\n`> dat2`\n\n`read.csv` simply invokes `read.table` with a different set of default\narguments. Notice that the default for `read.csv` is to include a\nheader.\n\n`> help(read.csv)`\n\n### Straight from Excel\n\nHowever it is possible to skip the .csv step using one of several\n**[R]{.sans-serif}** packages. Option 1: Use the Import Dataset button\nabove the environment window in **[R]{.sans-serif}**Studio (obviously\nthis only applies if using **[R]{.sans-serif}**Studio). Option 2: Use\nthe `read_excel` function in the `readxl` package (actually, Option 1\nuses Option 2). Option 3: use package `xlsx`. Option 4: \\...\n\nThese approaches may result in slightly different data formats. This is\nnot a problem, just be certain to investigate your data after loading.\n\n## Data from other Formats\n\n**[R]{.sans-serif}** can read directly from other formats with varying\nlevels of success. Functions exist for fixed width formats, .sas7bdat,\nSAS xport, SPSS, Stata, DBF, \\...\n\n## Exporting Data\n\n**[R]{.sans-serif}** has facilities for exporting data. Suppose you make\nchanges to a data set within **[R]{.sans-serif}** and you want to save\nthose changes permanently in a .csv or .xls file. The `write.csv`\ncommand exports an **[R]{.sans-serif}** object to a text file. All you\nhave to do is give `write.csv` two arguments: 1) the\n**[R]{.sans-serif}** object to be exported, and 2) the name of the file.\n\nFor example, `write.csv(M, \"newfile.csv\")` will export the\n**[R]{.sans-serif}** object `M` to a newly created file `newfile.csv`.\nWe will modify `dat2` to include an `id` variable, and we write the\nupdated data object to a csv file.\n\n`> dat2$id = 1:nrow(dat2)`\n\n`> dat2`\n\n`> write.csv(dat2, \"newfile.csv\")`\n\n**[R]{.sans-serif}** can also write to text files using `write.table`.\n\n## Missing Values in Data files\n\nData files can represent missing data in many ways. Often Excel files\nhave blank cells. Text files may use a special value such as 999 to\nrepresent missingness. SAS uses a period. Different codes may specify\ndifferent reasons for the missingness such as non-response or an\nunreasonable value.\n\nThere are several ways to convert these conventions to NA in\n**[R]{.sans-serif}** so they will (more likely) be treated properly in\nanalyses. (There are entire statistics courses on \"properly\" dealing\nwith missing data.)\n\nSuppose that the $88$ and $999$ are codes indicating missing values. We\nwant **[R]{.sans-serif}** to interpret these values as missing rather\nthan numeric. We can change these values to NA after reading in the\ndata. First we identify them and then replace them by NA.\n\n`> dat = read.csv(\"samp2.csv\")`\n\n`> dat`\n\n`> dat$z == 88 | dat$z == 999`\n\n`> dat$z[dat$z == 88 | dat$z == 999]`\n\n`> dat$z[dat$z == 88 | dat$z == 999] = NA`\n\n`> dat`\n\n### The `which` function\n\nWhile we are on the subject of missing data (NA) and logical values\n(TRUE, FALSE), I want to mention the `which` function. It statement\ntakes a logical statement (or a series of logical statements, some which\nmay be missing) as an argument. It returns the indices for which the\nlogical statement is TRUE.\n\n`> a = c(6, 9, 10, 2, 999, NA)`\n\n`> is.na(a)`\n\n`> which(is.na(a))`\n\n`> which(!is.na(a))`\n\n`> a == 999`\n\n`> a[a == 999]`\n\n`> which(a == 999)`\n\n`> a[which(a == 999)]`\n\n`> a[which(a == 999)] = NA`\n\n`> a`\n\n`> is.na(a)`\n\nThe `which` command is a very powerful tool for data management.\nConsider the following three scenarios:\n\n-   You have a data set and wish to perform an analysis on only males.\n\n-   All missing values have been coded as 99, 888, or 999.\n\n-   A scatterplot reveals several outliers, and you need to identify the\n    cases corresponding to the outliers.\n\nIn each scenario, `which` can be used to select the appropriate subset\nof the data.\n\n# Student t-tests\n\nA t-test is a statistical hypothesis test in which the test statistic\nfollows a t-distribution. Three common applications of the t-test are:\n\n-   A one-sample t-test of whether the mean of a normally distributed\n    population is a particular value ($H_0: \\mu = 70$)\n\n-   An independent samples t-test to determine whether the means of two\n    normally distributed populations are equal ($H_0: \\mu_1 = \\mu_2$)\n\n-   A paired samples t-test to determine whether the means of two\n    normally distributed populations are equal ($H_0: \\mu_1 = \\mu_2$)\n\nAnother t-test arises when testing whether a regression parameter equals\n0 ($H_0: \\beta_1 = 0$).\n\n## One-sample t-test\n\nClean up the workspace and import `height.csv` into\n**[R]{.sans-serif}**.\n\n`> rm(list=ls()) # removes all objects`\n\n`> dat = read.csv(\"height.csv\", header=TRUE)`\n\n`> head(dat)`\n\nLet's start with a one-sample t-test. Test the hypothesis that the\npopulation mean height for men is 70 inches ($H_0:\\mu_{men} = 70$)\n\nFirst we need to get the subset where gender $==$ male.\n\n`> dat$gender == \"male\"`\n\n`> men.ht = dat$height[dat$gender == \"male\"]`\n\nBefore doing any formal analyses, it is always a good idea to summarize\nthe data both numerically and visually.\n\n`> summary(men.ht)`\n\n`> boxplot(men.ht)`\n\n`> hist(men.ht, main=\"My First Histogram in R!\")`\n\nThe `t.test` function will perform a one sample t-test for the height of\nmen. Suppose we wish to test the hypothesis $H_0: \\mu_{men} = 70$ versus\nthe alternative $H_a: \\mu_{men} \\neq 70$. We must give the `t.test`\nfunction 1) the vector of male height values, and 2) the value of the\nmean under the null hypothesis. The default alternative is two-sided.\n\n`> t.test(men.ht, mu=70)`\n\nWhat if you want to calculate a 90% confidence interval?\n\n`> help(t.test)`\n\nThe *conf.level* argument will be used to change the confidence level.\n\n`> t.test(men.ht, mu=70, conf.level= 0.90)`\n\n`> t.out = t.test(men.ht, mu=70, conf.level= 0.90)`\n\n`> names(t.out)`\n\n`> t.out$conf.int`\n\n## Independent Samples t-tests\n\nNow suppose we wish to test whether there is a difference between the\npopulation mean heights for men and women ($H_0: \\mu_m = \\mu_w$). Before\nrunning the t-test, let's make side-by-side boxplots to visually compare\nthe heights of men and women.\n\n`> boxplot(men.ht, women.ht)`\n\n### The formula operator ($\\sim$)\n\nIt is possible to avoid creating separate vectors for two groups that\nyou would like to compare. This is done with the formula operator and\nmany R functions can accept a formula as the first argument. The second\nargument must then nearly always be the data.frame where the formula\nshould be evaluated.\n\n`> boxplot(height `$\\sim$` gender, data=dat)`\n\nIf you don't include the data argument, you'll likely get an error\nmessage:\n\n`> boxplot(height `$\\sim$` gender)` \\# error: data not found?\n\nThe variables in the `dat` data.frame can be made available temporarily\nby wrapping the command inside a call to `with`:\n\n`> with(dat, boxplot(height `$\\sim$` gender))`\n\nIf you need access to the variables in a data.frame for an extended\nsession and you aren't going to change the variables in the data.frame,\nyou can use the `attach(dat)` function to access height and gender\ndirectly. However, using `attach` is discouraged by some analysts. It\nputs a second copy of the data.frame on the \"search path\" and can make\nupdating your data tricky. **Remember to `detach` when you are done.**\n\n`> height`\n\n`> attach(dat)`\n\n`> height`\n\n`> detach(dat)`\n\n`> height`\n\nNow perform the independent samples t-test.\n\n`> t.test(height `$\\sim$` gender, data=dat)`\n\n# Chi-Square tests\n\nPearson's chi-square test is used to make two types of comparisons for\ncategorical variables. A *goodness of fit test* determines whether a\nparticular hypothesized distribution is reasonable for a categorical\nvariable. A *test of independence* assesses whether two categorical\nvariables are independent of each other.\n\n## Goodness of Fit\n\nSuppose a company wants to determine if employees are equally likely to\ncall in sick on any day of the week. That is, test the hypothesis\n$$H_0: p_1 = p_2 = p_3 = p_4 = p_5$$ where $p_1$ represents the\nprobability that a random call-in sick occurs on Monday, etc. The\nemployer collects data and obtains the following table\n\n::: center\n  ----- ----- ----- ----- -----\n    Mon   Tue   Wed   Thu   Fri\n     34    18    19    12    26\n  ----- ----- ----- ----- -----\n:::\n\nIf $H_0$ is true, the expected value in cell $i$ is $E_i = np_i$, where\n$n = 34 + 18 + 19 + 12 + 26 = 109$ and $p_i = 0.2$. The differences\nbetween the observed and expected values are combined into the $\\chi^2$\nstatistic. $$\\chi^2 = \\sum_i\\frac{(O_i - E_i)^2}{E_i}$$ If the null\nhypothesis is true, the $\\chi^2$ statistic approximately follows a\n$\\chi^2(k-1)$ distribution, where $k$ is the number of groups (5). This\napproximation is poor if the expected value in any cell is small.\n\nWe first need to get the data into **[R]{.sans-serif}**.\n\n`> days = c(34, 18, 19, 12, 26)`\n\n`> names(days) = c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\")`\n\n`> days`\n\nMany chi-square tests are performed using the `chisq.test` function.\n\n`> chisq.test(days)`\n\n**[R]{.sans-serif}** returns the $\\chi^2$ test statistic, the degrees of\nfreedom, and the p-value. Notice that we didn't specify that we were\ntesting the hypothesis that were testing the hypothesis of *equal*\nprobabilities. By default, `chisq.test` assumes a test of equal\nprobabilities unless the user specifies otherwise. If, for some reason,\nwe wanted to test the hypothesis that $p_1 = 0.35$, $p_2 = 0.1$,\n$p_3 = 0.1$, $p_4 = 0.1$, $p_5 = 0.35$, we can do so by passing the\nprobabilities to `chisq.test` in this way.\n\n`> chisq.test(days, p=c(0.35, 0.1, 0.1, 0.1, 0.35))`\n\nSo far, the output for the chi-square tests have been limited. What if\nwe wanted to obtain expected values or cell residuals? We unleash more\nof **[R]{.sans-serif}**'s capabilities by storing the value of the test\nas an object.\n\n`> cs.test = chisq.test(days)`\n\n`> names(cs.test)`\n\n`> cs.test$expected`\n\n`> cs.test$statistic`\n\n`> cs.test$residuals`\n\n## Chi-Square Test of Independence\n\nA Chi-Square Test of Independence tests for a relationship between two\ncategorical variables. We will use the \"UCBAdmissions data set\" to\nillustrate.\n\n`> data()`\n\n`> UCBAdmissions`\n\n`> class(UCBAdmissions)`\n\n`> dim(UCBAdmissions)`\n\nLet's select the second 2 by 2 table to perform a chi-square test of\nindependence.\n\n`> dat = UCBAdmissions[,,2]`\n\n`> dat`\n\nWhen we pass a vector of values to `chisq.test`, a test of homogeneity\nis performed by default. When we pass a table or matrix, a test of\nindependence is performed.\n\n`> chisq.test(dat)`\n\nThe default in **[R]{.sans-serif}** is to use Yates' continuity\ncorrection for 2x2 tables. You can opt not to use it.\n\n`> chisq.test(dat, correct=FALSE)`\n\n## Fisher's Exact Test\n\nPearson Chi-Square tests rely on an approximation that becomes poor as\ncell sizes get small. With smaller samples, Fisher's Exact Test might be\na good alternative. However, there are many flavors of Fisher's test.\n**[R]{.sans-serif}** has implemented many of them, including one in the\nbase package.\n\n`> fisher.test(dat)`\n\n# Linear Models\n\nIn a Linear Model, the expected value (mean) of a response variable,\n$Y$, is modeled as a linear combination of one or more predictors. The\nusual formulation of a linear model is as follows.\n$$E[Y] = \\beta_0 + \\beta_1X_1 + ... + \\beta_pX_p$$ We can also write\ndown a version of the model that includes a random component.\n$$Y = \\beta_0 + \\beta_1X_1 + ... + \\beta_pX_p + \\epsilon$$\n\n**Examples of Linear Models**\n\n-   Simple Linear Regression -- only one predictor\n\n-   ANOVA -- the predictors are dummy variables representing group\n    membership\n\n-   Multiple Linear Regression -- the predictors can be any combination\n    of binary, nominal, ordinal, and continuous\n\nEven an independent samples t-test is an example of a linear model. In\nthis case, there is only one predictor, $X$, which is a dummy variable\nrepresenting the group.\n\n### Another example of data entry\n\nThe *linmod.csv* data set contains the following measurements on 255\nindividuals.\n\n-   Systolic Blood Pressure\n\n-   Diastolic Blood Pressure\n\n-   Combined Blood Pressure\n\n-   Age\n\n-   Gender\n\n-   Smoking Status\n\nWe begin by reading in the data.\n\n`> dat = read.csv(\"linmod.csv\", header=TRUE)`\n\nBefore beginning any modeling, it's important to investigate the data to\nmake sure it is there as you expect. If we just type `dat` at the\ncommand line, **[R]{.sans-serif}** prints the entire data set. This is\nnot the most efficient way to explore the data. Here we explore several\ndifferent ways of exploring the data set in a more concise manner.\n\nThe `dim` function returns the dimensions of the data set; the `head`\nand `tail` functions enables us to see the first and last rows of the\ndata set.\n\n`> class(dat)`\n\n`> names(dat)`\n\n`> dim(dat)`\n\n`> head(dat)`\n\n`> head(dat, 15)`\n\n`> tail(dat)`\n\nThe `summary` function is a powerful method for summarizing variables in\nthe data set.\n\n`> summary(dat)`\n\nThe output includes a numeric summary for the variables *sbp* and *dbp*.\nThe *bp* column is read as *character* (and converted to a factor)\nbecause it contains the character \"/\". Instead of a numeric summary for\n*bp*, `summary` returns a table of values for the factor levels.\n\nWe would expect *age* to be a continuous variable, but\n**[R]{.sans-serif}** returns a table summary for *age* rather than a\nnumeric summary. This indicates that *age* is being read as a factor,\nand we should check for strings in the age column. In the *smoke*\ncolumn, we see that one person has the value $888$ and two the value\n$999$.\n\nAnother powerful function for investigating the structure of a data set\nis the `str` command.\n\n`> str(dat)`\n\nThe output lists *age* as a *factor* which confirms our suspicion that\n*age* is being read as a character variable. For factors, we can\ninvestigate the factor levels with the `levels` command.\n\n`> levels(dat$age)`\n\nSomeone has recorded \"Not Reported\\\" in the age column for one person.\nWith a data set as small as ours, we could type `dat` and scroll down to\nfind out which person had a \"Not Reported\\\" for age. With large data\nsets this is difficult. The `which` statement is another option.\n\n`> which(dat$age == \"Not Reported\")`\n\n`> dat[which(dat$age == \"Not Reported\"), ]`\n\nNow let's investigate the *smoke* variable.\n\n`> levels(dat$smoke)`\n\n`> which(dat$smoke == \"888\")`\n\n`> which(dat$smoke == \"999\")`\n\n**Fixing the Data** Suppose that 888 and 999 and \"Not Reported\" all\nindicate missing values. Let's update the *age* and *smoke* variables by\nputting NA to represent missingness.\n\n`> dat$age[189] = NA`\n\n`> dat$smoke[c(83,80,91)] = NA`\n\n`> summary(dat$smoke)`\n\n`> dat$smoke = factor(dat$smoke)`\n\n`> summary(dat$smoke)`\n\n**Common Data Management Problem!**\n\nWe still need to change *age* to a numeric variable. Just using\n`as.numeric` won't work on *factors*.\n\n`> as.numeric(dat$age)`\n\nInstead, we must first change it to character and then numeric.\n\n`> as.numeric(as.character(dat$age))`\n\n`> dat$age = as.numeric(as.character(dat$age))`\n\n### Solution\n\nAnother alternative is to read the data set using the `na.strings`\nargument.\n\n`> dat = read.csv(\"linmod.csv\", na.strings=c(\"NA\",\"Not Reported\",\"888\",\"999\"))`\n\n**Graphical Descriptions of Blood Pressure** Let's start by examining\nthe marginal distribution of Systolic Blood Pressure.\n\n`> hist(dat$sbp, main=\"Histogram of Systolic Blood Pressure\", xlab=\"Systolic BP\")`\n\n`> boxplot(dat$sbp, main=\"Boxplot of SBP\", ylab=\"SBP\")`\n\nNow use the `plot` function to create a scatterplot of Systolic Blood\nPressure versus Diastolic Blood Pressure. Suppose we want Diastolic\nBlood Pressure on the horizontal axis and Systolic Blood Pressure on the\nvertical axis. The horizontal axis is the first argument and the\nvertical axis is the second argument.\n\n`> plot(sbp `$\\sim$` dbp, data=dat)`\n\n`plot` has many arguments which will allow us to modify the graph. Let's\ntake a look at a few of them.\n\n`> plot(sbp `$\\sim$` dbp, data=dat, col=\"green\")`\n\n`> plot(sbp `$\\sim$` dbp, data=dat, pch=2, col=\"green\")`\n\n`> plot(sbp `$\\sim$` dbp, data=dat, pch=2, xlab=\"Diastolic\",`\n\n`+ ylab=\"Systolic\", main=\"Blood Pressure\", col=\"green\")`\n\n**Numerical Descriptions of Blood Pressure** Using the `sd`, `cov`, and\n`cor` functions, we can investigate the marginal and joint variation of\nDiastolic and Systolic Blood Pressure.\n\n`> summary(dat$dbp)`\n\n`> summary(dat$sbp)`\n\n`> sd(dat$dbp)`\n\n`> sd(dat$sbp)`\n\n`> cov(dat$dbp, dat$sbp)`\n\n`> cor(dat$dbp, dat$sbp)`\n\n## Simple Linear Regression using the `lm` function\n\nIn a simple linear regression, we propose the model:\n$$Y = \\beta_0 + \\beta_1 X + \\epsilon,$$ where $Y$ is the dependent\nvariable, $X$ is the sole independent variable, and $\\epsilon$\nrepresents a random component. One of the goals in a simple linear\nregression is to find the estimates, $\\hat{\\beta_0}$ and\n$\\hat{\\beta_1}$, that fit the data best.\n\nThe **[R]{.sans-serif}** function used to fit regression models is the\n`lm` function. Let's begin by doing a simple linear regression of\nsystolic blood pressure on diastolic blood pressure.\n\n`> lm(sbp `$\\sim$` dbp, data=dat)`\n\nAt first glance, **[R]{.sans-serif}** returns the estimated regression\nparameters $\\hat{\\beta_0}$ and $\\hat{\\beta_1}$ but very little else.\nWhat about the model $r^2$? How do we find the residuals? What about\nconfidence intervals, influential points, or the other diagnostics one\nshould consider when performing a regression analysis?\n\nBy storing the fitted model as an object, we are able to unleash all the\npower in the `lm` function. Let's try again, but this time, store the\nlinear model as an object.\n\n`> mymod = lm(sbp `$\\sim$` dbp, data=dat)`\n\nThe variable `mymod` now stores the information from the regression of\n`sbp` on `dbp`. `mymod` is a linear model object. Just as we earlier saw\nexamples of numeric objects (`x = 5`) and character objects\n(`y = \"Hi\"`), we now have the object `mymod` which is a linear model\nobject. Let's verify that `mymod` is a linear model object.\n\n`> class(mymod)`\n\nNow that we have the \"lm\\\" object stored in `mymod`, let's do some more\ninvestigation.\n\n`> summary(mymod)`\n\nThe `summary` function returns the following\n\n-   A 5-number summary of the residuals\n\n-   A table of regression coefficients, standard errors, t-statistics,\n    and p-values for testing the hypotheses that $\\beta_i = 0$\n\n-   An estimate of the error standard deviation\n\n-   Unadjusted and adjusted model $r^2$\n\n-   An overall F-test of no model effect\n\nWe can use the names function to see everything that is stored in\n`mymod`.\n\n`> names(mymod)`\n\nWe can extract any single attribute using \\$.\n\n`> mymod$coefficients`\n\n`> mymod$fitted.values`\n\n**[R]{.sans-serif}** has many \"extractor\" functions:\n\n`> coef(mymod)`\n\n`> fitted(mymod)`\n\n**[R]{.sans-serif}** also has powerful graphing tools for checking model\nassumptions. For a simple linear regression, we need to check for\n\n-   The nature of the relationship between $Y$ and $X$ (linear?)\n\n-   The error distribution\n\n-   Influential points\n\nUsing the `plot` function, we can cycle through diagnostic graphs to\ntest each of the above assumptions.\n\n`> plot(residuals(mymod), predict(mymod), main=\"Residual Plot\")`\n\nConfidence intervals for the regression coefficients provide much more\ninformation than p-values. Confidence intervals for $\\beta_0$ and\n$\\beta_1$ can be generated using the `confint` function.\n\n`> confint(mymod)`\n\n`> confint(mymod, level=.90)`\n\nWe can also examine the ANOVA table associated with the regression\nmodel.\n\n`> anova(mymod)`\n\n## Analysis of Variance\n\nSuppose one wishes to do a 2-way ANOVA model, where diastolic blood\npressure is the response with gender and smoking status the two factors.\nAs always, it is important to begin by investigating the relationships\ngraphically.\n\n`> boxplot(dbp `$\\sim$` smoke, data=dat)`\n\n`> boxplot(dbp `$\\sim$` gen, data=dat)`\n\n`> with(dat, interaction.plot(smoke, gen, dbp))`\n\nSince an ANOVA model is simply a linear model where the only predictors\nare dummy variables representing group membership, ANOVA models can be\nfit using the `lm` function.\n\n`> lm.mod = lm(dbp `$\\sim$` gen + smoke, data=dat)`\n\n`> summary(lm.mod)`\n\nMany researchers prefer output organized in a different ANOVA table. We\ncan also use the `aov` function to fit an ANOVA model.\n\n`> aov.mod = aov(dbp `$\\sim$` gen + smoke, data=dat)`\n\n`> summary(aov.mod)`\n\n`lm.mod` and `aov.mod` represent the same fit but the `summary` function\nreports them differently. `summary` is an example of a generic function.\nDifferent versions are used for different classes. Remember that we used\n`summary` earlier to describe numeric vectors, factors, and data.frames.\nLet's investigate the class of the two models.\n\n`> class(lm.mod)`\n\n`> class(aov.mod)`\n\nThe following commands give the mean of the dependent variable and each\nfactor level:\n\n`> model.tables(aov.mod)`\n\n`> ?model.tables`\n\nWe can use Tukey's HSD procedure to test the pairwise differences,\nadjusting for multiple testing:\n\n`> TukeyHSD(aov.mod)`\n\n`> ?TukeyHSD`\n\n## Multiple Linear Regression\n\nA multiple linear regression assumes the following relationship:\n$$Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + ... + \\beta_pX_p + \\epsilon$$\nIn this notation, $Y$ represents the response variable of interest, and\nthe $X_j$ correspond to predictor variables. When fitting a linear\nregression model, one aim to estimate the $\\beta$ parameters. The fitted\nmodel is sometimes used to predict future responses.\n\nWe will use the built-in LifeCycleSavings data set (which we saw in\npassing earlier) to illustrate fitting a multiple linear regression. We\nwill use the popular `car` (Companion to Applied Regression) package for\nsome regression diagnostics.\n\n`> data()`\n\nLet's first begin by learning about the data set.\n\n`> help(LifeCycleSavings)`\n\nShorten the name.\n\n`> Life=LifeCycleSavings`\n\nNow let's make a boxplot of each of the five variables. For comparison,\nit would be helpful to view all of the plots on the same output. The\n`par` and `mfrow` commands are useful for this. The `par` function\nallows you to set graphical parameters, and `mfrow` allows you to\nspecify an array of plots.\n\nThe following commands set up a two by two grid of plots.\n\n`> par(mfrow=c(2,2))`\n\nWe can add boxplots one at a time.\n\n`> boxplot(Life$sr, main=\"sr\")`\n\n`> boxplot(Life$pop15, main=\"pop15\")`\n\n`> boxplot(Life$pop75, main=\"pop75\")`\n\n`> boxplot(Life$dpi, main=\"dpi\")`\n\nAfter exploring the marginal relationships of each of the variables, it\nis a good idea to investigate the bivariate relationships. We do this\nboth numerically and graphically.\n\n`> cor(Life)`\n\n`> pairs(Life, panel=panel.smooth)`\n\nNow fit a multiple regression model using the `lm` function.\n\n`> mr.mod = lm(sr `$\\sim$` pop15 + pop75 + dpi + ddpi, data=Life)`\n\n`> summary(mr.mod)`\n\n`> confint(mr.mod)`\n\nWe saw that there was a large negative correlation between pop75 and\npop15. One diagnostic for multicolinearity is the variance inflation\nfactor (VIF). Let's investigate the variance inflation factors. It has\nbeen implemented in the `car` package. To access the function we must\nload the package:\n\n`> library(car)`\n\n`> ?vif`\n\n`> vif(mr.mod)`\n\nHow does the model change if we leave out one of the variables? We fit a\ndifferent model removing pop75.\n\n`> mr.mod2 = lm(sr `$\\sim$` pop15 + dpi + ddpi, data=Life)`\n\nWe now perform an F test for nested models.\n\n`> anova(mr.mod, mr.mod2, test=\"F\")`\n\n# Lists\n\n## String Manipulation\n\nIn the third column of *dat*, systolic and diastolic pressure were\nplaced together separated by a \"/\". Ideally, data would never be stored\nin such a manner. For easy data processing, systolic and diastolic blood\npressure should be stored in separate columns. Although in our data sets\nwe did have separate columns, suppose for the sake of example that we\nonly had the one column in which blood pressure was entered as $120/82$.\nIt could be time consuming to convert these to separate variables by\nhand in Excel.\n\nFortunately, **[R]{.sans-serif}** has excellent string manipulation\nfacilities. In this example, we will use the `strsplit` function to\nextract diastolic and systolic blood pressures. `strsplit` has two\narguments that we will use. The first argument is the character string\nwe wish to split. The second argument is the character that we will\nsplit on. Let's start with the *bp* value in the first row.\n\n`> b = dat$bp[1]`\n\n`> b`\n\nNow let's try to split `b` into two separate values.\n\n`> strsplit(b, split=\"/\")`\n\nThis didn't work. When a problem like this arises, be sure to look at\nthe error messages! In this example, **[R]{.sans-serif}** complains that\nwe have a \"non-character\\\" argument. Let's investigate.\n\n`> class(b)`\n\nSure enough, b is a factor since it was obtained by indexing a factor in\nthe data set. We must first change b to a character.\n\n`> b = as.character(b)`\n\n`> class(b)`\n\nNow we are ready!\n\n`> strsplit(b, split=\"/\")`\n\nThis seems to work, but in order to use the separated values, we must\nfirst store the split string as an object.\n\n`> sep = strsplit(b, split=\"/\")`\n\n`> sep`\n\n`> class(sep)`\n\n## Lists\n\nThe object `sep` is a list, a class of objects that we have not yet\nencountered explicitly (however, data.frames are lists). Lists can\nsimultaneously store many objects of various classes. Recall from\nearlier that elements of a vector were forced to be of the same class\n(e.g., character). Lists are much more flexible and can contain\ncharacters, vectors, matrices, data.frames, and even other lists. Let's\ntake a detour from our original problem of separating blood pressures in\norder to investigate lists.\n\nCreate a list containing a single number, a character, and a vector of\nnumber.\n\n`> L = list(5, \"Hi\", c(3,8,7))`\n\n`> L`\n\nThe syntax for indexing lists is different than that for vectors or\nmatrices. If we type `L[1]`, we obtain the sub-list containing 5 instead\nof just the number 5.\n\n`> L[1]`\n\n`> class(L[1])`\n\nInstead, we must use double-brackets to extract the number 5 rather than\nthe sublist containing the number 5.\n\n`> L[[1]]`\n\n`> class(L[[1]])`\n\nThe following extracts the 8 from the third element of the list.\n\n`> L[[3]][2]`\n\nNow that we have a basic understanding of lists. Let's return to our\nproblem of separating diastolic and systolic blood pressure.\n\n`> sep`\n\n`> s = sep[[1]][1]`\n\n`> d = sep[[1]][2]`\n\n`> s`\n\n`> d`\n\n`> s = as.numeric(s)`\n\n`> d = as.numeric(d)`\n\n`> s`\n\n`> d`\n\nIt worked! Now we need to do this for every person. One way this can be\naccomplished is with a `for` loop or `*apply`. We will revisit this\nafter covering programming. You can try the following but more is\nneeded.\n\n`> strsplit(as.character(dat$bp), split=\"/\")`\n\n# Generalized Linear Models (GLM)\n\nIn practice, GLMs are often used when the response variable is not\ncontinuous. Several examples of GLMs include\n\n-   Logistic Regression (Y is binary)\n\n-   Multinomial Logistic Regression (Y is nominal)\n\n-   Poisson Regression (Y is a count)\n\n-   Negative Binomial Regression (Y is a count with over-dispersion)\n\n**[R]{.sans-serif}** uses the function `glm` to fit GLMs. We will use\nlogistic regression to illustrate `glm`.\n\n## Logistic Regression\n\nLogistic regression is a specific type of GLM used to model a binary\noutcome. If we label a success \"1\" and a failure \"0\", the *odds* of\nsuccess are defined as $P(Y=1)/P(Y=0)$. Logistic regression models the\nlog odds of success as a linear combination of the predictors.\n$${\\rm log}\\left(\\frac{P(Y=1|X)}{P(Y=0|X)}\\right) =  \\beta_0 + \\beta_1X_1 + ... + \\beta_pX_p$$\n\nIn logistic regression, $\\beta_i$ is the effect of $X_i$ on the log odds\nof success ($Y=1$).\n\nFor an example, we use the \"Mroz\\\" data in the *car* library. Let's\nfirst review the \"Mroz\" data set.\n\n`> library(car)`\n\n`> help(Mroz)`\n\nThe syntax for `glm` is nearly the same as the syntax for `lm`. One\nimportant additional argument is *family*, which specifies what type of\nGLM will be fit. Logistic regression models a binary response, so we use\nthe binomial family.\n\n`> mroz.mod = glm(lfp `$\\sim$` I(k5==0) + age + wc + hc + lwg + inc, data=Mroz,`\n\n`+   family=binomial)`\n\n`> summary(mroz.mod)`\n\nThe fitted object `mroz.mod` is of a new type of class.\n\n`> class(mroz.mod)`\n\nWe can extract the estimated coefficients using `coef`.\n\n`> coef(mroz.mod)`\n\nWhen reporting the effects of a logistic regression analysis, it is\ncommon to include the effect on the *odds* of success. Since $\\beta_i$\nis the effect of $X_i$ on the log odds of success, $e^{\\beta_i}$ is the\neffect of $X_i$ on the odds of success[^1]. We can estimate the effects\nof the predictors on the odds by exponentiating the coefficients.\n\n`> exp(coef(mroz.mod))`\n\nWe can also obtain confidence intervals for both the log odds and odds\neffects.\n\n`> confint(mroz.mod)`\n\n`> exp(confint(mroz.mod))`\n\n# Creating Functions\n\nAnother very nice feature of **[R]{.sans-serif}** is the ability to\neasily write your own programs and functions. We will begin by creating\na new function called `add.machine` that will simply sum two numbers:\n\n`add.machine `$=$` function(num1, num2){`\\\n`result `$=$` num1 `$+$` num2`\\\n`return(result)`\\\n`}`\n\nThe following are important components of the code above:\n\n-   `add.machine` is the name of the newly created object\n\n-   `function` declares that `add.machine` will be a function\n\n-   `num1` and `num2` are the arguments that `add.machine` will take as\n    input\n\n-   The body of the function is enclosed in curly braces\n\n-   `return` (is optional) but specifies the output that is returned\n    from the function\n\nLet's test out the newly created function\n\n`> add.machine`\n\n`> add.machine(3,5)`\n\nWhat happens if we don't specify valid arguments?\n\n`> add.machine(3)`\n\n`> add.machine(3, \"Hi\")`\n\n# Programming\n\nProgramming in **[R]{.sans-serif}** is basically the same as programming\nin any other language; the core program is controlled by a series of\nif-then statements, loops, print statements, calls to other programs,\nand return statements. The only differences are minor syntax conventions\nthat just take practice.\n\n## Branching\n\nTo begin with, let's look at an example of how if-then statements work\nin **[R]{.sans-serif}**. Try submitting this command at the prompt to\nsee how it works:\n\n`> if (1>0) print(\"I Like Binary\")`\n\nNote that **[R]{.sans-serif}** prints \"I Like Binary\\\" because the\ncondition in the *if* statement is true. The `print` function is very\nuseful for programming purposes, in that it prints simple strings in the\n**[R]{.sans-serif}** Console. No explicitly labeled *then* statement is\nneeded after an *if* statement; you simply type what you would like\n**[R]{.sans-serif}** to do if the *if* condition is true. In general, if\nyou want to do more than one thing if the *if* condition is true, you\nuse this bracketed structure:\n\n`if (logical condition) {`\\\n`do this`\\\n`and this`\\\n`and this`\\\n`}`\n\nThe statements in the brackets usually refer to function calls and\nobject assignments, and simply need to be on separate lines (no\npunctuation necessary!). If necessary, you can use an \"else\" option:\n\n`> if (x>5) print(\"x is big\") else print(\"x is small\")`\n\n## Looping\n\nNow let's take a look at how a \"for\" loop works in **[R]{.sans-serif}**.\nTry submitting the following syntax at the command prompt:\n\n`> for (i in 1:5) print(i)`\n\n**[R]{.sans-serif}** prints 1, 2, 3, 4, and 5. *For* loops work like\n*if* conditions, and if you want **[R]{.sans-serif}** to do more than\none thing in a *for* loop, use brackets around the commands:\n\n`for(i in a:b) {`\\\n`do this`\\\n`and this`\\\n`and this`\\\n`}`\n\n`while` and `repeat` loops in **[R]{.sans-serif}** work in a manner very\nsimilar to other programming languages. One or more commands are\nexecuted repeatedly while a condition remains true. Typically a counter\nobject is initialized for controlling the loop, and then incremented\nwithin the while loop while certain commands are executed for each\nrepetition. The loop ends when the while condition is false.\n\n`t = 0`\\\n`while(t < 7) {`\\\n`print(t)`\\\n`t = t+1`\\\n`}`\n\n## Blood Pressure Example Revisited\n\nEarlier we dealt with a data set where diastolic and systolic blood\npressure had been read into a single column separated. We learned how to\nextract the two blood pressures using the `strsplit` function. Now that\nwe have discussed creating functions and programming, we will separate\nthe two measurements for the entire data set. We begin by clearing up\nthe workspace.\n\n`> ls()`\n\n`> rm(list=ls())`\n\n`> dat = read.csv(\"linmod.csv\", header=TRUE, na.strings=c(\"NA\", 888, 999, \"Not Reported\"))`\n\nExtract a blood pressure for practice.\n\n`> b = dat$bp[1]`\n\nRecall that the following commands successfully extracted the separated\nmeasurements.\n\n`> ## Change to character.`\n\n`> b = as.character(b)`\n\n`> sep = strsplit(b, split=\"/\")`\n\n`> ## Extract systolic blood pressure.`\n\n`> s = sep[[1]][1]`\n\n`> ## Extract diastolic blood pressure.`\n\n`> d = sep[[1]][2]`\n\n`> ## Convert to numeric.`\n\n`> s = as.numeric(s)`\n\n`> d = as.numeric(d)`\n\nNow we enclose the following commands in a function. We will name this\nfunction `extract.bp`.\n\n`> extract.bp = function(x) {`\n\n`> x = as.character(x)`\n\n`> sep = strsplit(x, split=\"/\")`\n\n`> s = as.numeric(sep[[1]][1])`\n\n`> d = as.numeric(sep[[1]][2])`\n\n`> return(c(s,d))`\n\n`> } `\n\nType `extract.bp` at the command line to verify the creation of the\nfunction was successful.\n\n`> extract.bp`\n\nNow let's experiment to see if our function works.\n\n`> b`\n\n`> extract.bp(b)`\n\nThe following code uses a loop to extract the blood pressures for each\nvariable in the data set.\n\n`> ## Number of rows in the data set.`\n\n`> n = dim(dat)[1]`\n\n`> ## Set up empty numeric vectors to store two blood pressures.`\n\n`> systolic = numeric(n)`\n\n`> diastolic = numeric(n)`\n\n`> ## Loop over the rows and extract.`\n\n`> for (j in 1:n){`\n\n`> out = extract.bp(dat$bp[j])`\n\n`> systolic[j] = out[1]`\n\n`> diastolic[j] = out[2]`\n\n`> } `\n\n`> systolic`\n\n`> diastolic`\n\n## The `apply` Function\n\nThe `apply` function performs a function on each row or column of a\nmatrix. (There are other \\*apply functions for other situations.) First\ncreate a couple matrices to play with. In addition to the `matrix`\nfunction, `rbind` (or `cbind`) can be used to create matrices. For\nexample,\n\n`> c1 = c(2, 9, 3)`\n\n`> c2 = c(12, 1, 5)`\n\n`> M2 = cbind(c1, c2)`\n\n`> M2`\n\n`> apply(M2, 2, mean)`\n\nIn the example above, `apply` took three arguments:\n\n1.  The first argument, \"M2\" is the matrix\n\n2.  The second argument, \"2\", is an index indicating the function is\n    applied separately for each column, a value of \"1\" would apply the\n    function on each row\n\n3.  The last argument is the function that is applied\n\nIf you were to just type `mean(M2)`, the mean would be computed over the\nentire matrix.\n\n`> mean(M2)`\n\n[^1]: $\\beta_i$ is an additive effect, and $e^{\\beta_i}$ is a\n    multiplicative effect. For example, if $\\beta_i = 0.38$, we would\n    estimate that the log odds of success increases by 0.38 for every\n    unit increase in $X_i$. If $e^{\\beta_i} = 1.46$, we would estimate\n    that the odds of success increases by 46 *percent* for every unit\n    increase in $X_i$.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"notes.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]},"callout-appearance":"simple"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}