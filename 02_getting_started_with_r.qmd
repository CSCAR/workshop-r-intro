# Getting Started with **[R]{.sans-serif}**

## The RStudio interface

The first screen we see in R should look like this:

[![The first screen we see when we open RStudio](./images/rstudio_first_screen.jpg)](./images/rstudio_first_screen.jpg)

Here, there are three main window panes. The "Console" window is where we type the code to tell the computer to do stuff.

The "Environment-History-Connections" window has three tabs. "Environment" 
shows the objects that we have saved during our session (I will explain this 
soon); "History" shows a record of all the code we asked the computer to run; and "Connections"—which we will not use here—shows we the connections we have to remote databases.

The "Files-Plots-Packages" window has several tabs. "Files" shows us all the 
files in our current working directory, which is the default location where R 
will look for files we want to load and where it will put any files we save. 
"Plots" will display the plots we make in R. "Packages" shows us the packages 
installed in our computer and whether they are loaded in our current session. 
"Help" allows us to search and read the documentation for packages and 
functions. "Viewer" can display content that usually belongs to a web browser 
(i.e., html files).

We can tell **[R]{.sans-serif}** to do stuff by typing *commands* in the line that begins with `>` in the  console window. This line is called "command prompt". Let's begin with something simple:

```{r simplest operation}
1 + 1
```

The `[1]` that appears next to the result informs us that the line begins with the first value in the result. This information is helpful when we run commands that produce multiple values, like in this case:

```{r quick sequence of numbers}
80:110
```

If we type an incomplete command, R will assume that we are still writing and 
will show a `+`. This `+` is *not* an arithmetical operator; it's a prompt for us to continue writing in the next line. The prompt will not go away unless we complete the command or we press the "Escape" key. For example:

```{r}
#| eval: false
> 42 -
+
+
+ 1
[1] 41
```

If R does not understand a command, it will display an error message.

```{r}
#| eval: false
> 7 % 2
Error: unexpected input in "7 % 2"
>
```

## Using R as a Calculator

**[R]{.sans-serif}** can perform basic arithmetic operations. Type the
following expressions at the command prompt (the line that begins with `>`) in
the **[R]{.sans-serif}** console window.

```{r simple arithmetic}
5 + 3
5 - 3
5*3
5/3
5^3
5**3
4 + 2 * 3
(4 + 2) * 3
```

If we try to do shoddy math, we will get a message (but not necessarily an error):
```{r}
#| error: true
0/0
1/0
-1/0
```

**Be careful of comparisons and floating point arithmetic**:

```{r}
(.1 + .2) == .3
5 == sqrt(5)^2
5 - sqrt(5)^2
```

<!--
The `all.equal` function will test if two values are "close enough":

`> all.equal(5, sqrt(5)^2)`

`> ?all.equal`
-->

This is not **[R]{.sans-serif}**'s fault. All computers have a limited space to 
store numbers and decimal positions. So, computers often use numbers with 
"hidden" decimals even when it looks like they use round numbers. For example, 
what we think of as `3` may actually be `3.000005`. This is common enough to 
make the **[R]{.sans-serif}** [FAQ (7.31)](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f). To quote from "The Elements of Programming Style", 
by Kernighan and Plauger: "10.0 times 0.1 is hardly ever 1.0."

Let's do a quick exercise to practice. Think of an integer, double it, add six, divide it in half, subtract the number you started with, and then square it. If your code is correct, the answer should be nine. Try it yourself!

Being able to do all these computations is good and all, but what happens if we want to use a result later without redoing the computation? **[R]{.sans-serif}** can save numbers (and more) using something called "objects".

## Objects

In simple terms, an object is a named piece of information. A single number, a word, a plot, and a set of instructions can all be objects if we name them. The name allows us to access the piece of information whenever we want. To create an object, we must first choose a name, then type an arrow `<-` (a "lower than" symbol `<` followed by a "minus" sign `-`), and then write the value that we want to save.

```{r create first object}
my_object <- 42
```

Another way of creating the object is to use the "equal to" sign `=` instead of the arrow.

```{r create first object method 2}
my_object = 42
```

In this context, both `<-` and `=` are acting as "assignment operators" because they assign the value `42` to the name `my_object`. In **[R]{.sans-serif}**, `=` has several uses, so if you want to avoid any possible confusion, I suggest you use `<-`. But as long as you are consistent, you can pick whichever symbol you like the most.

Now the environment window shows that there is an object called `my_object`, which we can access at anytime by typing its name.

```{r call my_object}
my_object
```

And because `my_object` has a number as its value, we can do mathematical operations with it.

```{r}
my_object + 7
my_object/11
my_object**my_object
```

Be careful with names. If we try to reuse a name, **[R]{.sans-serif}** will overwrite the previous object without notifying us in any way.

```{r}
a <- 2
a
a <- 711
a
```


We can use almost any name you want, but there are a few rules:

+ Names can be a combination of letters, digits, period `.` and underscore `_`.
+ If a name starts with a period `.`, it can *not* be followed by a digit.
+ Names can *not* start with a number or an underscore `_`.
+ Names are case-sensitive (`age`, `Age` and `AGE` are three different variables)
+ Reserved words can *not* be used as variables (`TRUE`, `FALSE`, `NULL`, `if`, ...).
+ Names can *not* include white spaces.

There are also a few suggestions that will save you many hours of frustration:

+ It's never a good idea to give your object the same name as a built-in function.
+ If you need to create objects with multiple words in their name then use either an underscore (`my_value`) or a dot (`my.value`) between words, or capitalize the different words (`MyValue`). I like to use an underscore format (called [snake case](https://en.wikipedia.org/wiki/Snake_case))
+ Use informative names. It is quick and easy to use names like `x` or `my_value`. But your code will be easier and faster to understand if you use names that illustrate what you want to do with the object. Your colleagues and your future self will really appreciate it.

## Using functions

**[R]{.sans-serif}** has many built-in functions for anything from basic math to advanced statistical models. Functions are also objects in **[R]{.sans-serif}**. But instead of storing a single number as we did before, functions store commands that we can apply to an input. For example, we can round a number, calculate the square root, the factorial, or the natural logarithm. To use a function, we must write the name of a function followed by the data we want it to use inside a pair of round brackets.

```{r simple mathematical functions}
round(2.1415)
sqrt(9)
factorial(7)
log(100)
```

The information inside the round brackets is called an "argument". `sqrt()` and `factorial()` only use one argument (the number that we want to use). But other functions---like `round()` and `log()`---can take more arguments to modify their behavior. For example, in `round()`, the first argument corresponds to the number we want to round, and the second argument corresponds to the number of decimal places that we want to keep. The arguments are separated by commas.

```{r rounding to different decimal places}
round(2.1415, 0)
round(2.1415, 2)
```

The order of the arguments is important. What happens if we try to run `round(2, 2.1415)`? Fortunately, arguments have names that you can use to specify which data to use in each case. So, we can write

```{r naming arguments}
round(x = 2.1415, digits = 3)
```

Even better, we can pass arguments in any order as long as we name them all

```{r}
round(digits = 3, x = 2.1415)
```

But if we use the wrong name in a function, we will probably get an error message

```{r}
#| error: true
round(x = 2.1415, basket = 3)
```

A quick way to check what arguments we can use is to use another function called `args`, which takes the name of a function as its argument:

```{r}
args(round)
```

The output shows that `round()` has two arguments: `x` (the number we want to round) and `digits`. It also shows that `digits` is already set to zero. This means that **[R]{.sans-serif}** will use `0` as the default value. Arguments with default values are optional because we can choose to modify them or not.

I encourage we to name all the arguments in the function, or at least the ones after the first argument. It is hard to remember all the arguments that can go into more complicated functions. And it is even harder to remember the correct order. Accidentally switching the order of the arguments can produce wrong results without us knowing. Naming the arguments will prevent errors and clarify the function's behavior.

So far we have been working with only a single number at the time. But **[R]{.sans-serif}** can also work with groups of numbers by using something called "vectors".

## Working with vectors of numbers

In **[R]{.sans-serif}**, an ordered group of numbers is called a vector. To create a vector of numbers, 

**Review of logarithms** If $a^y = x$, then $\log_a(x) = y$. For example, $10^2 = 100$ and $\log_{10}(100) = 2$. Three common choices of
the base are $10$, $2$, and $e$. What is the default choice in
**[R]{.sans-serif}**?

`> log(10)`

`> log(2)`

`> log(exp(1))`

One of the most important functions in **[R]{.sans-serif}** is the function `c()` (short for "combine").

This is your first indication that an **[R]{.sans-serif}** function may
behave differently depending on the *type* of input.

`> sqrt(NA)`

`> exp(1)`

An *argument* is a parameter that is passed to a function. The `sqrt`
and `exp` functions only take a single argument. Many functions,
including `log`, take more than one argument. Arguments are separated by
commas.

`> round(5.123, 2)`

If not all arguments are provided, **[R]{.sans-serif}** may use a
default value.

`> round(5.123)`

Some other basic functions:

`> ceiling(5.123)`

`> floor(5.123)`

The "Remainder" and Integer Division operations:

`> 17 %% 5`

`> 17 %/% 5`



If try to use a missing value (represented in **[R]{.sans-serif}** by `NA`) in a computation, the output will likely be missing:

`> (4 + NA) * 3`

Suppose you are working with a dataset and you wish to apply the
$\log_{10}$ transformation. How can we instruct **[R]{.sans-serif}** to
take logarithms base 10? **[R]{.sans-serif}**'s help pages are good
sources of information for questions such as these. Two ways to view a
function's help page are '?' and 'help'. A more generic approach might
be searching "take log in r" with your favorite search engine.

`> ?log`

`> help(log)`

The `log` function can take two arguments including the *base* argument.
Arguments can be specified in several ways.

The argument name can be stated explicitly:

`> log(x=25, base=5)`

The argument name can be abbreviated as long as the abbreviation is
unique:

`> log(x=25, b=5)`

Not all arguments need to be named:

`> log(25, b=5)`

`> log(b=5, 25)`

We don't have to use the argument names at all, in which case the
arguments are matched by the order listed. Compare

`> log(25, 5)`

`> log(5, 25)`

**[R]{.sans-serif}** may return an error if you incorrectly name a
function argument.

`> log(25, be=5)`

## Making Comparisons: Logical Operators

**[R]{.sans-serif}** has logical operators that will return "TRUE" or
"FALSE" (or possibly "NA" if you have missing values).

`> 5 == 6`

`> 5 != 6`

`> 5 < 6`

`> 5 > 6`

`> 5 <= 6`

`> 5 <= NA`

`> 5 <= Inf`

`> !TRUE`

`> (1 + 2) == 3`

**[R]{.sans-serif}** has "and" and "or" operators (there are others):

`> (5 < 6) & (7 == 8)`

`> (5 < 6) | (7 == 8)`

`> (5 < 6) | NA`



## Vectors and Sequences

**[R]{.sans-serif}** is a 'vectorized' language. Many functions operate
on an entire vector of numbers as easily as on a single number. This
feature allows the user to think in terms of manipulating entire data
variables rather than one data element at a time. For example (once we
have learned about storing objects), we can write `mean(Height)` or
`hist(Height)` to analyze a variable, rather than working with the
individual data values.

Thus it is important to be able to create and manipulate vectors.
Numbers can be combined into a vector with the function 'c', which
stands for *combine*.

`> c(3, 9, 2)`

The following commands produce exactly the same output, namely a vector
with the integers 1 to 10. In **[R]{.sans-serif}**, there are often many
ways of doing the same thing.

`> c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)`

`> 1:10`

`> seq(1, 10, 1)`

`> seq_len(10)`

`> ?seq`

You can specify a sequence's increment or length using the *by* and
*length* arguments.

`> seq(0, 200, by=4)`

`> seq(0, 200, length=13)`

`> rep(3, 12)`

In **[R]{.sans-serif}**, functions can be nested. In the following
examples, the inner function, `c`, is used to create a vector and the
outer function uses that vector as an argument.

`> rep(c(3,9,2), times=4)`

`> rep(c(3,9,2), each=4)`

`> rep(c(3,9,2), length=12)`

`> rep(c(3,9,2), times=c(2,9,1))`

## Matrices and Arrays

In **[R]{.sans-serif}**, a matrix or an array is just a vector with a
dimension *attribute*. The `matrix` command can rearrange a vector into
a matrix.

`> matrix(1:12, nrow=3)`

What happens if we don't specify the number of rows using the argument
`nrow`?

`> matrix(1:12)`

The result is still a matrix, but the default is to put each element in
a separate row. What happens if we specify an inappropriate number of
rows?

`> matrix(1:12, nrow=5)`

When the number of rows and the number of elements are not coherent,
**[R]{.sans-serif}** issues a warning.

A vector has 1 dimension; a matrix has 2 dimensions; an array can have
any number of dimensions. These have 3 dimensions:

`> array(1:12, dim=c(2,2,3))`

`> array(1:12, dim=c(2,3,2))`

