# Getting Started with **[R]{.sans-serif}**

## The RStudio interface

The first screen you see in R should look like this:

[![The first screen you see when you open RStudio](./images/rstudio_first_screen.jpg)](./images/rstudio_first_screen.jpg)

Here, there are three main window panes. The "Console" window is where you type the code to tell the computer to do stuff.

The "Environment-History-Connections" window has three tabs. "Environment" 
shows the objects that you have saved during your session (I will explain this 
soon); "History" shows a record of all the code you asked the computer to run; and "Connections"—which we will not use here—shows you the connections you have to remote databases.

The "Files-Plots-Packages" window has several tabs. "Files" shows you all the 
files in your current working directory, which is the default location where R 
will look for files you want to load and where it will put any files you save. 
"Plots" will display the plots you make in R. "Packages" shows you the packages 
installed in your computer and whether they are loaded in your current session. 
"Help" allows you to search and read the documentation for packages and 
functions. "Viewer" can display content that usually belongs to a web browser 
(i.e., html files).

You can tell **[R]{.sans-serif}** to do stuff by typing *commands* in the line that begins with `>` in the  console window. This line is called "command prompt". Let's begin with something simple:

```{r simplest operation}
1 + 1
```

The `[1]` that appears next to the result informs you that the line begins with the first value in the result. This information is helpful when you run commands that produce multiple values, like in this case:

```{r quick sequence of numbers}
80:110
```

If you type an incomplete command, R will assume that you are still writing and 
will show a `+`. This `+` is *not* an arithmetical operator; it's a prompt for you to continue writing in the next line. The prompt will not go away unless you complete the command or you press the "Escape" key. For example:

```{r}
#| eval: false
> 42 -
+
+
+ 1
[1] 41
```

If R does not understand a command, it will display an error message.

```{r}
#| eval: false
> 7 % 2
Error: unexpected input in "7 % 2"
>
```

## Using **[R]{.sans-serif}** as a Calculator

**[R]{.sans-serif}** can perform basic arithmetic operations. Type the
following expressions at the command prompt (the line that begins with `>`) in
the **[R]{.sans-serif}** console window.

```{r simple arithmetic}
5 + 3
5 - 3
5*3
5/3
5^3
5**3
4 + 2 * 3
(4 + 2) * 3
```

If you try to do shoddy math, you will get a message (but not necessarily an error):
```{r}
#| error: true
0/0
1/0
-1/0
```

Let's do a quick exercise to practice. Think of an integer, double it, add six, divide it in half, subtract the number you started with, and then square it. If your code is correct, the answer should be nine. Try it yourself!

## Objects

To keep it simple, you can think of an object as a named piece of information. A single number, a word, a plot, and a set of instructions can all be objects if you name them. The name allows you to store the piece of information so that you can access it in the future.  

To create an object, you must first choose a name, then type an arrow `<-` (a "lower than" symbol `<` followed by a "minus" sign `-`), and then write the value that you want to save.

```{r create first object}
my_object <- 42
```

Another way of creating the object is to use the "equal to" sign `=` instead of the arrow.

```{r create first object method 2}
my_object = 42
```

In this context, both `<-` and `=` are acting as "assignment operators" because they assign the value `42` to the name `my_object`. In **[R]{.sans-serif}**, `=` has several uses, so if you want to avoid any possible confusion, I suggest you use `<-`. But as long as you are consistent, you can pick whichever symbol you like the most.

Now the environment window shows that there is an object called `my_object`, which you can access at anytime by typing its name.

```{r call my_object}
my_object
```

And because `my_object` has a number as its value, you can do mathematical operations with it.

```{r}
my_object + 7
my_object/11
my_object**my_object
```

If you try to reuse a name, **[R]{.sans-serif}** will overwrite the previous object without notifying you in any way.

```{r}
a <- 2
a
a <- 711
a
```


You can use almost any name you want, but there are a few rules:

+ Names can be a combination of letters, digits, period `.` and underscore `_`.
+ If a name starts with a period `.`, it can *not* be followed by a digit.
+ Names can *not* start with a number or an underscore `_`.
+ Names are case-sensitive (`age`, `Age` and `AGE` are three different variables)
+ Reserved words can *not* be used as variables (`TRUE`, `FALSE`, `NULL`, `if`, ...).
+ Names can *not* include white spaces.

There are also a few suggestions that will save you many hours of frustration:

+ It's never a good idea to give your object the same name as a built-in function.
+ If you need to create objects with multiple words in their name then use either an underscore (`my_value`) or a dot (`my.value`) between words, or capitalize the different words (`MyValue`). I like to use an underscore format (called [snake case](https://en.wikipedia.org/wiki/Snake_case))
+ Use informative names. It is quick and easy to use names like `x` or `my_value`. But your code will be easier and faster to understand if you use names that illustrate what you want to do with the object. Your colleagues and your future self will really appreciate it.

## Using functions

**[R]{.sans-serif}** has many built-in functions for anything from basic math to advanced statistical models. For example, you can round a number, calculate the square root, the factorial, or the natural logarithm. To use a function, you must write the name of a function followed by the data you want it to use inside a pair of round brackets.

```{r simple mathematical functions}
round(2.1415)
sqrt(9)
factorial(7)
log(100)
```

The information inside the round brackets is called an "argument". `sqrt()` and `factorial()` only need one argument to work (the number that you want to use). But other functions---like `round()` and `log()`---can take more arguments to modify their behavior. For example, in `round()`, the first argument corresponds to the number you want to round, and the second argument corresponds to the number of decimal places that you want to keep. The arguments are separated by commas.

```{r rounding to different decimal places}
round(2.1415, 0)
round(2.1415, 2)
```

The order of the arguments is important. What happens if you try to run `round(2, 2.1415)`? Fortunately, arguments have names that you can use to specify which data to use in each case. So, you can write

```{r naming arguments}
round(x = 2.1415, digits = 3)
```

Even better, you can pass arguments in any order as long as you name them all

```{r}
round(digits = 3, x = 2.1415)
```

But if you use the wrong name in a function, you will probably get an error message

```{r}
#| error: true
round(x = 2.1415, basket = 3)
```

A quick way to check what arguments you can use is to use another function called `args`, which takes the name of a function as its argument:

```{r}
args(round)
```

Here you can see that the `digits` argument is already set to zero. This means that **[R]{.sans-serif}** will use `0` as the argument unless you explicitly tell it otherwise. Arguments with default values are optional because you can choose to modify them or not.

I encourage you to name all the arguments in the function, or at least the ones after the first argument. More complicated functions can take several arguments and it is hard to remember all of them. And inadvertently switching the order can produce wrong results without you knowing. Naming the arguments will prevent errors and will help you know what exactly the functions do when you use them.

**Review of logarithms** If $a^y = x$, then $\log_a(x) = y$. For example, $10^2 = 100$ and $\log_{10}(100) = 2$. Three common choices of
the base are $10$, $2$, and $e$. What is the default choice in
**[R]{.sans-serif}**?

`> log(10)`

`> log(2)`

`> log(exp(1))`

One of the most important functions in **[R]{.sans-serif}** is the function `c()` (short for "combine").

This is your first indication that an **[R]{.sans-serif}** function may
behave differently depending on the *type* of input.

`> sqrt(NA)`

`> exp(1)`

An *argument* is a parameter that is passed to a function. The `sqrt`
and `exp` functions only take a single argument. Many functions,
including `log`, take more than one argument. Arguments are separated by
commas.

`> round(5.123, 2)`

If not all arguments are provided, **[R]{.sans-serif}** may use a
default value.

`> round(5.123)`

Some other basic functions:

`> ceiling(5.123)`

`> floor(5.123)`

The "Remainder" and Integer Division operations:

`> 17 %% 5`

`> 17 %/% 5`



If try to use a missing value (represented in **[R]{.sans-serif}** by `NA`) in a computation, the output will likely be missing:

`> (4 + NA) * 3`

Suppose you are working with a dataset and you wish to apply the
$\log_{10}$ transformation. How can we instruct **[R]{.sans-serif}** to
take logarithms base 10? **[R]{.sans-serif}**'s help pages are good
sources of information for questions such as these. Two ways to view a
function's help page are '?' and 'help'. A more generic approach might
be searching "take log in r" with your favorite search engine.

`> ?log`

`> help(log)`

The `log` function can take two arguments including the *base* argument.
Arguments can be specified in several ways.

The argument name can be stated explicitly:

`> log(x=25, base=5)`

The argument name can be abbreviated as long as the abbreviation is
unique:

`> log(x=25, b=5)`

Not all arguments need to be named:

`> log(25, b=5)`

`> log(b=5, 25)`

We don't have to use the argument names at all, in which case the
arguments are matched by the order listed. Compare

`> log(25, 5)`

`> log(5, 25)`

**[R]{.sans-serif}** may return an error if you incorrectly name a
function argument.

`> log(25, be=5)`

## Making Comparisons: Logical Operators

**[R]{.sans-serif}** has logical operators that will return "TRUE" or
"FALSE" (or possibly "NA" if you have missing values).

`> 5 == 6`

`> 5 != 6`

`> 5 < 6`

`> 5 > 6`

`> 5 <= 6`

`> 5 <= NA`

`> 5 <= Inf`

`> !TRUE`

`> (1 + 2) == 3`

**[R]{.sans-serif}** has "and" and "or" operators (there are others):

`> (5 < 6) & (7 == 8)`

`> (5 < 6) | (7 == 8)`

`> (5 < 6) | NA`

**Be careful of comparisons and floating point arithmetic**:

`> (.1 + .2) == .3`

`> 5 == sqrt(5)^2`

`> 5 - sqrt(5)^2`

The `all.equal` function will test if two values are "close enough":

`> all.equal(5, sqrt(5)^2)`

`> ?all.equal`

This is not bug of **[R]{.sans-serif}**. It is a feature of computers
using binary representation of floating point numbers and storing them
with finite precision. This is common enough to make the
**[R]{.sans-serif}** FAQ (7.31):
`https://cran.r-project.org/doc/FAQ/R-FAQ.html`. To quote from "The
Elements of Programming Style" by Kernighan and Plauger: "10.0 times 0.1
is hardly ever 1.0."

## Vectors and Sequences

**[R]{.sans-serif}** is a 'vectorized' language. Many functions operate
on an entire vector of numbers as easily as on a single number. This
feature allows the user to think in terms of manipulating entire data
variables rather than one data element at a time. For example (once we
have learned about storing objects), we can write `mean(Height)` or
`hist(Height)` to analyze a variable, rather than working with the
individual data values.

Thus it is important to be able to create and manipulate vectors.
Numbers can be combined into a vector with the function 'c', which
stands for *combine*.

`> c(3, 9, 2)`

The following commands produce exactly the same output, namely a vector
with the integers 1 to 10. In **[R]{.sans-serif}**, there are often many
ways of doing the same thing.

`> c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)`

`> 1:10`

`> seq(1, 10, 1)`

`> seq_len(10)`

`> ?seq`

You can specify a sequence's increment or length using the *by* and
*length* arguments.

`> seq(0, 200, by=4)`

`> seq(0, 200, length=13)`

`> rep(3, 12)`

In **[R]{.sans-serif}**, functions can be nested. In the following
examples, the inner function, `c`, is used to create a vector and the
outer function uses that vector as an argument.

`> rep(c(3,9,2), times=4)`

`> rep(c(3,9,2), each=4)`

`> rep(c(3,9,2), length=12)`

`> rep(c(3,9,2), times=c(2,9,1))`

## Matrices and Arrays

In **[R]{.sans-serif}**, a matrix or an array is just a vector with a
dimension *attribute*. The `matrix` command can rearrange a vector into
a matrix.

`> matrix(1:12, nrow=3)`

What happens if we don't specify the number of rows using the argument
`nrow`?

`> matrix(1:12)`

The result is still a matrix, but the default is to put each element in
a separate row. What happens if we specify an inappropriate number of
rows?

`> matrix(1:12, nrow=5)`

When the number of rows and the number of elements are not coherent,
**[R]{.sans-serif}** issues a warning.

A vector has 1 dimension; a matrix has 2 dimensions; an array can have
any number of dimensions. These have 3 dimensions:

`> array(1:12, dim=c(2,2,3))`

`> array(1:12, dim=c(2,3,2))`

