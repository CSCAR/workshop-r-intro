[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Preface\nThese self-contained notes are intended for anyone that wants to use R but has little or no experience using it, and little or no experience in programming. Faculty and staff from “Consulting for Statistics, Computing & Analytics Research” (CSCAR) wrote these notes to support in-person workshops at the University of Michigan. During these workshops, we also use a slideshow based on these notes, which is available here.\nCSCAR is a unit of the Office of the Vice President of Research at the University of Michigan. We offer U-M researchers guidance and training in data collection, management, and analysis; and in the use of technical software and advanced computing in research.\nIf you are a member of the faculty, professional staff, or a student at the University of Michigan, you can access our free, one-hour consultations with graduate-level statisticians. To request an appointment—which can be remote or in person—you can send an email to deskpeople@umich.edu, or you can fill this form. You can also walk-in for a consultation with one of our Graduate Student Research Assistants (GSRAs). GSRAs are available Monday through Friday, between 9am and 5pm (we close on Tuesdays between noon and 1pm).\nCSCAR can also help with simple statistical questions through email. You can write to stats-consulting@umich.edu.\nFor more information on CSCAR, please visit http://cscar.research.umich.edu/.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#who-are-this-notes-for",
    "href": "index.html#who-are-this-notes-for",
    "title": "Introduction to R",
    "section": "Who are this notes for?",
    "text": "Who are this notes for?\nThese notes are a intended for anyone that wants to use R but has little or no experience using it, and little or no experience in programming. These notes are self-contained and form the basis for in-person workshops hosted by CSCAR (see contact information below). During the workshops, we also use a slideshow based on these notes. This slideshow is available here.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#creation-of-this-document",
    "href": "index.html#creation-of-this-document",
    "title": "Introduction to R",
    "section": "Creation of this document",
    "text": "Creation of this document\nThese notes are published using Quarto; the source code is available at https://github.com/CSCAR/workshop-r-intro.\nYou can switch between light and dark modes using the button in the top left corner of the screen. Dark mode reverses the colors of the images to reduce brightness. To show an image in its original colors, move your mouse over it (or press it if you are on a mobile device). All images link to more detailed full-size versions.\nIf you have any questions or comments about these notes, you can contact Abner Heredia Bustos (abnerhb@umich.edu).",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#contact-information",
    "href": "index.html#contact-information",
    "title": "Introduction to R",
    "section": "Contact information",
    "text": "Contact information\n\nCSCAR\nhttp://cscar.research.umich.edu/\nConsulting for Statistics, Computing and Analytics Research",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Introduction to R",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nWe thank Abner Heredia Bustos, Josh Errickson, Xiru Lyu, and Chris Andrews for their contributions to these notes over the years.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01_the_r_environment.html",
    "href": "01_the_r_environment.html",
    "title": "1  The R Environment",
    "section": "",
    "text": "1.1 Why becoming a useR?\nR is gratis and runs on Windows, MacOS, and several Unix platforms. With R you can start with a data set like this:\ntreat nitrogen block height weight leafarea shootarea flowers\n1   tip   medium     1    7.5   7.62     11.7      31.9       1\n2   tip   medium     1   10.7  12.14     14.1      46.0      10\n3   tip   medium     1   11.2  12.76      7.1      66.7      10\n4   tip   medium     1   10.4   8.78     11.9      20.3       1\n5   tip   medium     1   10.4  13.58     14.5      26.9       4\nand, in 8 lines of code or less, make a plot like this:\nYou can also find many powerful tools to fit statistical models (both bayesian and frequentist), including:\nEven better, new tools become available in R all the time because, as with other open source programming languages, everyone can examine and contribute to R’s code. Users constantly publish their own code packages to expand R’s capabilities. As of March 2019, users have contributed over 13,700 packages to Comprehensive R Archive Network (CRAN), many of which perform complex statistical routines that are not (and may never be) available in other statistical software systems.\nIn Windows, there are several ways to use R. The standard R graphical unit interface (GUI) allows you to point and click to do many basic tasks. Another GUI is R Commander, developed by John Fox at McMaster University. R Commander displays the underlying R code for each analysis to help the user learn the programming language. Tinn-R is another GUI from Jose Claudio Faria.\nThese GUIs are friendly and easy to grasp if you’re a beginner. But to use all of R’s capabilities you will need to do more than point and click. A more complete way of using R is through an integrated development environment IDE), which, in short, helps you code. The most popular IDE for R is RStudio, which organizes the user’s screen into panes that display scripts, objects, graphics, and the R console.\nIn these notes, we will use RStudio a lot. The goal is for you to start taking full advantage of R’s capabilities.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The R *Environment*</span>"
    ]
  },
  {
    "objectID": "01_the_r_environment.html#why-becoming-a-user",
    "href": "01_the_r_environment.html#why-becoming-a-user",
    "title": "1  The R Environment",
    "section": "",
    "text": "Generalized linear models (including linear regression)\nSurvival analysis\nTime series analysis\nMultilevel models (aka hierarchical models, aka Random and Mixed effects models)\nClassification and clustering\nSample size and power calculations\nMultivariable analysis (e.g., factor analysis, principal component analysis, and structural equations modeling)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The R *Environment*</span>"
    ]
  },
  {
    "objectID": "01_the_r_environment.html#why-isnt-everyone-a-user",
    "href": "01_the_r_environment.html#why-isnt-everyone-a-user",
    "title": "1  The R Environment",
    "section": "1.2 Why Isn’t Everyone a UseR?",
    "text": "1.2 Why Isn’t Everyone a UseR?\nMany users of statistics don’t use R because they only know how to use one statistical software, often the one taught in their first statistics course. In the past, R rarely was this first language, but nowadays more schools are teaching how to use it.\nSome people have used R, but struggled to get comfortable and productive with it, especially if they had little coding experience. Typing commands explicitly is more difficult than pointing and clicking. Also, each package has its own rules to learn. We can find a lot of good help for popular packages written by professional developers, but not so much for smaller packages written by other amateur users. Worst of all, some of the messages R displays if we make a mistake are uninformative, so fixing the problem can be difficult.\nDon’t get frustrated! You don’t have to be an expert programmer to use R, and the benefits are worth spending some time up front.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The R *Environment*</span>"
    ]
  },
  {
    "objectID": "01_the_r_environment.html#suggestions-for-learning-r",
    "href": "01_the_r_environment.html#suggestions-for-learning-r",
    "title": "1  The R Environment",
    "section": "1.3 Suggestions for Learning R",
    "text": "1.3 Suggestions for Learning R\n\nLearn interactively! Retype and experiment with lots of sample code; you won’t break it. These notes contain many code examples and you can find many more online.\nDon’t worry about getting errors. Even experienced R users make mistakes all the time, and you can learn a lot from error messages.\nAsk other R users for help.\nSome useful links are:\n\nhttps://www.r-project.org: The R Home page, the central webpage for the R project. Here you will find links for downloading R, downloading additional packages for R, and almost everything else that you would like to know about the software or the people behind it.\nhttps://cran.r-project.org/web/views/: Task views summarize the most important packages involved in a subject field or analysis type.\nhttps://journal.r-project.org: The R Journal\nhttps://stats.stackexchange.com: Cross-Validated\nhttps://www.r-bloggers.com\nhttps://stats.idre.ucla.edu/r/: Institute for Digital Research and Education at UCLA\nhttps://socialsciences.mcmaster.ca/jfox/: John Fox’s home page\nhttps://sas-and-r.blogspot.com/: Examples of code to perform same task in SAS and R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The R *Environment*</span>"
    ]
  },
  {
    "objectID": "01_the_r_environment.html#how-to-get-r",
    "href": "01_the_r_environment.html#how-to-get-r",
    "title": "1  The R Environment",
    "section": "1.4 How to get R",
    "text": "1.4 How to get R\nAt the R Project Web Page the most important link is at the left hand side of the screen, under the “Download” heading. Click on the CRAN link (Comprehensive R Archive Network), and, after you choose one of the U.S. mirrors, you will be taken to the page that you will use to download everything R-related.\nOnce you find the CRAN web page, take the following steps to obtain R:\n\nClick on “Download R for X” that best describes your operating system (Linux, OS X, Windows).\nWhen using Windows, click on the “base” subdirectory. This will allow you to download the base R packages.\nClick the “Download R 4.X.X for Windows” link. R is updated quite frequently. At the time of this printing, version 4.4.2 is available. Save the .exe file somewhere on your computer.\nDouble-click on the .exe file once it is downloaded. An installation window will appear to guide you through the setup of R in your machine.\nOnce you finish, you should have an R icon on your desktop that gives you a shortcut to the R system.\n\n\n1.4.1 How to get RStudio\nRStudio is already installed on the lab workstations. The following information is useful if you need to install RStudio on another machine. You must install R before you install RStudio. Otherwise, RStudio will not work.\nVisit https://posit.co/downloads/ and click on “Download RStudio”. Choose the version for your operating system (Linux, OS X, Windows) and download the installer. Then double click on the installer .exe file and follow the instructions on the screen to install RStudio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The R *Environment*</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html",
    "href": "02_getting_started_with_r.html",
    "title": "2  Getting Started with R",
    "section": "",
    "text": "2.1 The RStudio interface\nThe first screen we see in R should look like this:\nHere, there are three main window panes. The “Console” window is where we type the code to tell the computer to do stuff.\nThe “Environment-History-Connections” window has three tabs. “Environment” shows the objects that we save during our session (I will explain this soon); “History” shows a record of all the code we ask the computer to run; and “Connections” (which we will not use here) shows us the connections we have to remote databases.\nThe “Files-Plots-Packages” window has several tabs. “Files” shows us all the files in our current working directory, which is the default location where R will look for files we want to load and where it will put any files we save. “Plots” will display the plots we make in R. “Packages” shows us the packages installed in our computer and whether they are loaded in our current session. “Help” allows us to search and read the documentation for packages and functions. “Viewer” can display content that usually belongs to a web browser (i.e., html files).\nWe can tell R to do stuff by typing commands in the line that begins with &gt; in the console window. This line is called “command prompt”. Let’s begin with something simple:\n1 + 1\n\n[1] 2\nThe [1] that appears next to the result informs us that the line begins with the first value in the result. This information is helpful when we run commands that produce multiple values, like in this case:\n80:110\n\n [1]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[20]  99 100 101 102 103 104 105 106 107 108 109 110\nIf we type an incomplete command, R will assume that we are still writing and will show a +. This + is not an arithmetical operator; it is a prompt for us to continue writing in the next line and will not go away unless we complete the command or we press the “Escape” key. For example:\n&gt; 42 -\n+\n+\n+ 1\n[1] 41\nIf R does not understand a command, it will display an error message.\n&gt; 7 % 2\nError: unexpected input in \"7 % 2\"\n&gt;\nIn this case, what I meant was\n7 %% 2\n\n[1] 1",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#the-rstudio-interface",
    "href": "02_getting_started_with_r.html#the-rstudio-interface",
    "title": "2  Getting Started with R",
    "section": "",
    "text": "The first screen we see when we open RStudio",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#using-r-as-a-calculator",
    "href": "02_getting_started_with_r.html#using-r-as-a-calculator",
    "title": "2  Getting Started with R",
    "section": "2.2 Using R as a calculator",
    "text": "2.2 Using R as a calculator\nR can perform basic arithmetic operations. Type the following expressions at the command prompt (the line that begins with &gt;) in the R console window.\n\n5 + 3\n\n[1] 8\n\n5 - 3\n\n[1] 2\n\n5*3\n\n[1] 15\n\n5/3\n\n[1] 1.666667\n\n\nR can also do exponentiation with ^1; modulus, also known as remainder from division, with %%; and integer division with %/%.\nIf we try to do shoddy math, R will inform us (but not necessarily with an error message):\n\n0/0\n\n[1] NaN\n\n-1/0\n\n[1] -Inf\n\n\nR also has logical operators that will return “TRUE” or “FALSE”.\n\n5 == 6\n\n[1] FALSE\n\n5 != 6\n\n[1] TRUE\n\n5 &lt; 6\n\n[1] TRUE\n\n\nThe logical operators “and” (&) and “or” (|) allow us to combine multiple logical statements:\n\n(5 &lt; 6) & (7 == 8)\n\n[1] FALSE\n\n(5 &lt; 6) | (7 == 8)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThink of an integer, double it, add six, divide it in half, subtract the number you started with, and then square it. If your code is correct, the answer should be nine.\n\n\nBe careful with comparisons and floating point arithmetic:\n\n(.1 + .2) == .3\n\n[1] FALSE\n\n(.1 + .2) - .3\n\n[1] 5.551115e-17\n\n\n\nThis imprecision is not R’s fault. All computers have limited space to store numbers and decimal positions, so they often use numbers with “hidden” decimals even when it looks like they use round numbers. For example, what looks like a 3 may actually be 3.000005. You can find more information about this imprecision in FAQ (7.31).\nBeing able to do these computations is nice, but what happens if we want to use a result later without redoing or retyping everything? R can save numbers (and more) using something called “objects”.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#objects",
    "href": "02_getting_started_with_r.html#objects",
    "title": "2  Getting Started with R",
    "section": "2.3 Objects",
    "text": "2.3 Objects\nIn simple terms, an object is a named piece of information that we can access whenever we want. A single number, a word, a plot, and a set of instructions can all be objects if we name them. To create an object, we must first choose a name, then type an arrow &lt;- (this is a “lower than” symbol &lt; followed by a “minus” sign -), and then write the value that we want to save.\n\nmy_object &lt;- 42\n\nAnother way of creating the object is to use the “equal to” sign = instead of the arrow.\n\nmy_object = 42\n\nIn this context, both &lt;- and = are acting as “assignment operators” because they assign the value 42 to the name my_object. In R, the symbol = has several common uses, so if you want to avoid confusion, I suggest you use &lt;-. But you can pick whichever symbol you like the most as long as you are consistent.\nNow the environment window shows that there is an object called my_object, which we can access at anytime by typing its name.\n\n\n\nThe environment pane with an object\n\n\n\nmy_object\n\n[1] 42\n\n\nmy_object has a number as its value, so we can do mathematical operations with it.\n\nmy_object + 7\n\n[1] 49\n\nmy_object^my_object\n\n[1] 1.501309e+68\n\n\nWe can also create objects based on other objects.\n\na &lt;- 10\nb &lt;- a\na\n\n[1] 10\n\nb\n\n[1] 10\n\n\nBe careful: if we try to reuse a name, R will overwrite the previous object without notifying us in any way.\n\nc &lt;- 2\nc\n\n[1] 2\n\nc &lt;- 711\nc\n\n[1] 711\n\n\nHowever, if an object is the copy of another object, overwriting the original does not affect the copy; and overwriting the copy does not affect the original.\n\na &lt;- 10\nb &lt;- a\nb\n\n[1] 10\n\na &lt;- 5\nb\n\n[1] 10\n\n\nWe can name our objects in almost any way we want. The only rules are:\n\nNames can be a combination of letters, digits, periods . and underscores _.\nNames cannot include white spaces.\nIf a name starts with a period ., it cannot be followed by a digit.\nNames cannot start with a number or an underscore _.\nNames are case sensitive (for example, age, Age and AGE are three different objects).\nReserved words (like TRUE, FALSE, NULL, if, …) cannot be used as names.\n\nAlso, here are a few suggestions that can save you many hours of frustration:\n\nAvoid giving your object the same name as a built-in function.\nIf you need to create objects with multiple words in their name, separate them with an underscore (my_object) or a dot (my.object), or capitalize the different words (MyObject). Choose whichever format you like most and be consistent with it.\nUse informative names. It is quick and easy to use names like x or value1. But your code will be easier and faster to understand if your objects have names that illustrate their purposes. Your colleagues and your future self will really appreciate it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#using-functions",
    "href": "02_getting_started_with_r.html#using-functions",
    "title": "2  Getting Started with R",
    "section": "2.4 Using functions",
    "text": "2.4 Using functions\nR has many built-in functions to do anything from basic math to text manipulation to advanced statistical models. R thinks of functions as objects that store commands that we can apply to an input. For example, we can input a number to round it, or to calculate its square root, its factorial, or its natural logarithm. To use a function, we must write the name of a function followed by the input we want it to use inside a pair of round brackets.\n\nround(2.1415)\nsqrt(9)\nfactorial(7)\nlog(100)\n\nThe pieces of information inside the round brackets are called “arguments”. Some functions, like sqrt() and factorial(), only use one argument (the number that we want to use). But other functions, like round() and log(), can take more arguments (separated by commas) to modify their behavior. For example, round() accepts a second argument that corresponds to the number of decimal places that we want to keep.\n\nround(2.1415, 0)\n\n[1] 2\n\nround(2.1415, 2)\n\n[1] 2.14\n\n\nThe order of these arguments is important (what happens if we try to run round(2, 2.1415)?) Fortunately, arguments have names that we can use to specify which data to use in each case. So, we can write\n\nround(x = 2.1415, digits = 3)\n\n[1] 2.142\n\n\nEven better, we can pass arguments in any order as long as we name them all.\n\nround(digits = 3, x = 2.1415)\n\n[1] 2.142\n\n\nNote that using the wrong name in a function will likely yield an error message.\n\nround(x = 2.1415, basket = 3)\n\nError in round(x = 2.1415, basket = 3): unused argument (basket = 3)\n\n\nA quick way to check what arguments we can use is to invoke args(), which takes the name of a function as its argument:\n\nargs(round)\n\nfunction (x, digits = 0, ...) \nNULL\n\n\nThe output shows that round() has two arguments: x, which is the number we want to round; and digits, which determines how many decimal places to keep. The output also shows that digits is already set to zero. This means that round will use 0 as the default value for digits, i.e., it will not keep any decimal places. We can omit arguments with default values and R will automatically fill them for us in the background.\nI encourage you to name all the arguments you define when using a function, or at least the ones after the first argument. It is hard to remember all the arguments that can go into more complicated functions, and it is even harder to remember them in the correct order. It is easy to accidentally switch unnamed arguments and get wrong results without even noticing. This is why naming the arguments will prevent errors and clarify the function’s behavior.\nWe can also run functions inside other functions. This works because R first runs the innermost function and then uses the result in the outermost function.\n\nsqrt(round(16.483, digits = 0))\n\n[1] 4\n\n\nThe functions we have used are simple and intuitive to use. But sometimes we need to know more about a function before we can use it. Where can we find explanations to help us?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#getting-help",
    "href": "02_getting_started_with_r.html#getting-help",
    "title": "2  Getting Started with R",
    "section": "2.5 Getting help",
    "text": "2.5 Getting help\nThe help() function allows us to access R’s built-in help information on any function. For example, to open the help page for round(), we do\n\nhelp(round)\n\nA shorter way of writing this is to use ? before the name of the function.\n\n?round\n\nAfter you run the code, the help page is displayed in the “Help” tab in the “Files-Plots-Packages” pane (usually in the bottom right of RStudio).\nAs a novice user, help pages may seem arcane—perhaps because they aim for shortness and use technical vocabulary. But this short vocabulary makes (most of) the explanations precise, so we can use the information we need without having to read the entire document. Also, all help pages are organized similarly, so we don’t have to relearn how to navigate them. With a bit of practice, you will be able to find exactly what you need in mere seconds.\nThe first line of the help document displays the name of the function and the package that contains the function. Other sections are:\n\nDescription: summarizes the function.\nUsage: names the arguments associated with the function and possible default values.\nArguments: describes the purpose and format of each input.\nDetails: explicates what the function does and how it does it.\nValue: if applicable, describes the type and structure of the object that the function returns.\nSee Also: suggests other help pages with similar or related content.\nExamples: shows code to illustrate how to use the function. We can copy and paste examples in the console, and we can access them at any time by using the example() function (e.g., example(\"round\")).\n\n\n\n\n\n\n\nHow to get started with help pages?\n\n\n\nStart by reading the help pages of functions that you already understand. This will teach you how to understand the structure of the pages and will familiarize you with the jargon. As you use R you will likely need other, more complicated functions, so reading more help pages will happen almost naturally.\nKeep in mind that help pages explain the code, not the underlying concepts. If you don’t know what it means to round a number, reading the documentation for round() will not help you.\n\n\nhelp() is useful if we know the full name of the function. But if all we remember is a key word in the name, we can search through R’s help system using help.search()\n\nhelp.search(\"round\")\n\nNote that in this case we have to use quotes \" \" around the name of the function. We can also use the shortcut ??\n\n??round\n\nAs before, the ‘Help’ tab in RStudio will display the results of the search. help.search() looks for the pattern in the help documentation, code demonstrations, and package vignettes and displays the results as clickable links that we can follow.\nAnother useful function is apropos(), which lists all functions containing a specified character string. Note that apropos() returns names even when the word we used is only part of a larger word, like in “surround”. For example, to find all functions with round in their name, we use2\n\napropos(\"round\")\n\n[1] \"round\"        \"round.Date\"   \"round.POSIXt\"\n\n\nAnother useful function is RSiteSearch(), which allows us to search for keywords and phrases in function help pages and vignettes for all CRAN packages, and in CRAN task views. This way we can access the online search engine directly from the Console and display the results in our web browser.\n\nRSiteSearch(\"regression\")\n\n\nUntil now, the console satisfied all our coding needs. But if we wanted to reuse a command from before, we would have to either rewrite it from scratch, or look tediously through our command history in the “Environment-History-Connections” window. Besides, once we close this session in RStudio, all of our work will be gone, like tears in the rain. It would be much better if we wrote our code in a place where we can easily review and modify it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#working-with-scripts",
    "href": "02_getting_started_with_r.html#working-with-scripts",
    "title": "2  Getting Started with R",
    "section": "2.6 Working with scripts",
    "text": "2.6 Working with scripts\nA script is a plain text file where we write our code. With a script we can edit, proofread, and reuse code; we can easily write multi-line code (which is cumbersome to do in the console); and we can save our code so we can come back to it later or share it with others. I think the best way to code in R is to use a script, and I strongly suggest you always use one.\nTo open a script, click on File &gt; New File &gt; R script in the menu bar on the upper left-hand side of the screen.\n\n\n\nA screen with a new script\n\n\nWe can run a line of code in the script using the Run button in the upper right-hand side of the script window (see picture below). R will run whichever line of code your cursor is on. We can also run all of the code in the script by clicking the Source button that’s next to Run. Since I find clicking buttons slow, I use a keyboard shortcut to run a line of code: Control + Enter in Windows and Linux; Command + Enter in Mac.\n\n\n\nButtons for running code\n\n\nTo save your script, you can click on the blue square3 right below the tab with the script name. The first time you save your script, R will ask you to choose a name and a location to save your file in. I strongly suggest that you pick a name and a location that you will remember easily in the future.\nMoving forward, I will write all my code in a script and will assume you are doing the same. Trust me, it’s for your own benefit.\nNow that we know how to preserve our hard-gained code, we can do more elaborate work. Previously we worked with one number at the time. But we can also work with groups of numbers (and of other stuff) by using something called “vectors”.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#working-with-vectors",
    "href": "02_getting_started_with_r.html#working-with-vectors",
    "title": "2  Getting Started with R",
    "section": "2.7 Working with vectors",
    "text": "2.7 Working with vectors\nIn R, an ordered group of numbers is called a vector. To create a vector of numbers, we need to use the function c() (short for “combine”). The arguments of c() are the numbers you want to use in the vector, in the order you want to use them.\n\nmy_vec &lt;- c(5, 3, 7, 1, 1, 8) # This is a vector of numbers\nmy_vec\n\n[1] 5 3 7 1 1 8\n\n\n\n\n\n\n\n\nComments\n\n\n\nDid you see the text I added next to the code? R will ignore everything in a line that comes after a hashtag #, also known as commenting symbol. Comments can explain confusing chunks of code, or warn future users about potential problems.\n\n\nVectors can also contain other types of data, like words:\n\nvector_of_words &lt;- c(\"monday\", \"lemon\")\nvector_of_words\n\n[1] \"monday\" \"lemon\" \n\n\nNote that we must enclose words in quotation marks to let R know that we want to use “monday” and “lemon” as values and not as names for objects. Look at what happens if we forget the quotation marks:\n\nvector_of_words &lt;- c(monday, lemon)\n\nError: object 'monday' not found\n\n\nLater on we will work more with vectors of words, but for now let’s focus on vectors of numbers.\n\n2.7.1 Named vectors\nWe can name the elements of a vector if we add a name followed by an equal size before the value that we want to save:\n\nmy_named_vec &lt;- c(tigers = 2, lions = 5)\nmy_named_vec\n\ntigers  lions \n     2      5 \n\n\nNamed vectors help us store more information in the same object. They also give us another way of accessing the elements inside the vector.\n\n\n2.7.2 Operations with numerical vectors\nR is a “vectorized” language, which means that it can often operate on an entire vector of numbers as easily as on a single number. All the logical and mathematical functions we used before work with vectors:\n\nmy_vec / 11\n\n[1] 0.45454545 0.27272727 0.63636364 0.09090909 0.09090909 0.72727273\n\nmy_vec &lt;= 7\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\nlog(my_vec)\n\n[1] 1.609438 1.098612 1.945910 0.000000 0.000000 2.079442\n\nmy_vec*my_vec\n\n[1] 25  9 49  1  1 64\n\n\nIn the last example, R did not obey the rules of linear algebra to multiply two vectors. Instead, R used “element-wise execution”, which means that R applied the same operation to each element of the vector independently of the other elements.\nTo decide how to apply element-wise execution, R considers the length of the vectors, which refers to the number of elements inside them. When we use two vectors with the same length, R will line up the vectors and perform a sequence of individual operations. For instance, in my_vec*my_vec, R multiplies the first element of vector 1 by the first element of vector 2, then the second element of vector 1 by the second element of vector 2, and so on, until all elements are multiplied. The result will be a new vector with the same length as the first two.\nWhen we use two vectors with different lengths, R will repeat the shorter vector until it has as many elements as the longer vector, and then it will do the same as before. For example:\n\nmy_vec * c(1, 2)\n\n[1]  5  6  7  2  1 16\n\n\nIf the length of the short vector does not divide evenly into the length of the long vector, R will do an incomplete repeat of the shorter vector and return a warning.\n\nmy_vec * c(1, 2, 3, 4)\n\nWarning in my_vec * c(1, 2, 3, 4): longer object length is not a multiple of\nshorter object length\n\n\n[1]  5  6 21  4  1 16\n\n\nRepeating the numbers of the vector is known as “vector recycling”, and it helps R do element-wise operations.\nElement-wise execution allows us to apply the same instruction to all elements in an object rather than one element at a time. When working with a data set, element-wise execution will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise execution also facilitates writing our functions in R.\nR can do vector and matrix multiplications, but we have to ask for them explicitly. For example, to get the inner product, we need the operator %*%; and to get the outer product, we need %o%. Don’t worry if you are not familiar with matrix operations; you won’t need them in these notes.\n\n\n2.7.3 Extracting elements\nWe can access specific elements of vectors using the square bracket [ ] notation. To use it, we first write the name of the vector we want to extract from, followed by the square brackets with an index of the element we wish to extract. This index can be a position, a logical statement, or a name (if available). To extract elements based on their position we simply write the position number inside the [ ]. For example, to extract the 3rd value of my_vec, we use\n\nmy_vec[3]\n\n[1] 7\n\n\nWe can store this value in another object.\n\nvalue_3 &lt;- my_vec[3]\n\nWe can also extract multiple elements at the time by using a vector of indices inside the square brackets:\n\nmy_vec[c(1, 3, 5)]\n\n[1] 5 7 1\n\n\nOr we can use : notation. Remember that : helps us create a sequence of values. For example,\n\n3:6\n\n[1] 3 4 5 6\n\n\nSo,\n\nmy_vec[3:6]\n\n[1] 7 1 1 8\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, the positional index starts at 1, so to call the first element of a vector we need to use [1]. In many other programming languages (like Python and C++), the positional index starts at 0.\n\n\nIf the elements of the vector have names, we can extract a value using its name (surrounded by quotes) instead of a positional index.\n\nmy_named_vec\n\ntigers  lions \n     2      5 \n\nmy_named_vec[\"lions\"]\n\nlions \n    5 \n\n\nAnother convenient way to extract elements from a vector is to use a logical expression as an index. For example, to extract all elements greater than 4 from my_vec, we do\n\nmy_vec[my_vec &gt; 4]\n\n[1] 5 7 8\n\n\nThis works because R uses element-wise execution even for logical statements. So, my_vec &gt; 4 asks if each item of my_vec meets the condition “greater than four” and returns the corresponding vector of TRUE and FALSE. Then, when we add this result to the square brackets, R examines each element of my_vec asking “should I extract this element?”. If the answer is TRUE, the value is extracted; if it’s FALSE, the value is ignored. Under the hood, using my_vec &gt; 4 is equivalent to\n\nmy_vec[c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE)]\n\n[1] 5 7 8\n\n\nTwo useful functions to extract values of a vector are head(), which extracts the first few values of a vector; and tail(), which gives us the last few values of a vector. Try them yourself!\n\n\n2.7.4 Replacing elements\nWe can replace the elements of a vector by combining the square bracket notation with the assignment operator. For example, to replace the second element of my_vec, we do\n\nmy_vec[2] &lt;- 99\nmy_vec\n\n[1]  5 99  7  1  1  8\n\n\nTo replace multiple elements with the same value, say, elements 5 and 6, we do\n\nmy_vec[c(5, 6)] &lt;- 55\nmy_vec\n\n[1]  5 99  7  1 55 55\n\n\nR can also do element-wise replacement:\n\nmy_vec[c(5, 6)] &lt;- c(100, 200)\nmy_vec\n\n[1]   5  99   7   1 100 200\n\n\nWhat happens if you try to replace two values with a vector that has three (or more) values?\nLogical expressions help us replace values that meet specific conditions without having to find them ourselves.\n\nmy_vec[my_vec &gt; 44] &lt;- -1\nmy_vec\n\n[1]  5 -1  7  1 -1 -1\n\n\n\n\n2.7.5 Reordering elements of vectors\nTo sort the elements of a vector from lowest to highest, we can use sort()\n\nsorted_vec &lt;- sort(my_vec)\nsorted_vec\n\n[1] -1 -1 -1  1  5  7\n\n\nIf we want to sort from highest to lowest, we need to set the optional argument decreasing to TRUE.\n\nsorted_vec_decreasing &lt;- sort(my_vec, decreasing = TRUE)\nsorted_vec_decreasing\n\n[1]  7  5  1 -1 -1 -1\n\n\nAnother option is to first use sort() and then reverse the sorted vector using rev().\n\nsorted_vec_decreasing &lt;- rev(sort(my_vec))\nsorted_vec_decreasing\n\n[1]  7  5  1 -1 -1 -1\n\n\nA more useful feature of vectors is that we can reorder their elements based on the values of other vectors. To show this, let’s first create a vector of city names and a vector with (my guess of) their typical daily temperatures in degrees Fahrenheit.\n\ncities &lt;- c(\"Tokyo\", \"Cairo\", \"Mexico City\", \"Helsinki\")\ntemps_fahr &lt;- c(50, 90, 65, -10)\n\nNow imagine that we want to order the vector of cities, going from coldest to hottest. The first step is to use order() to create a new variable called “temps_order”.\n\ntemps_order &lt;- order(temps_fahr)\ntemps_order\n\n[1] 4 1 3 2\n\n\nThis output says that the lowest value in temps_fahr is in the fourth position, the second lowest value is in the first position, and so on. We can think of temps_order as a vector of positional indices of temperatures in ascending order. Now we can use these indices to reorder the vector of cities.\n\ncities_ordered &lt;- cities[temps_order]\ncities_ordered\n\n[1] \"Helsinki\"    \"Tokyo\"       \"Mexico City\" \"Cairo\"      \n\n\nTa-da!\nThese vector manipulations can do more than dazzle your friends. Imagine that we have a data set with two columns of data and that we want to sort it based on the values of the first column. If we use sort() on each column separately, the values of each column will become uncoupled from each other. Instead, we can use order() on one column to make a vector of positional indices. Then we can use these indices on both columns to keep the values of each coupled in the original way.\nSo far we have relied on R’s built-in capabilities to do everything we need. But sometimes we need to do something for which there isn’t a built-in function. In these cases, we can get inventive and write a function ourselves.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#writing-our-own-functions",
    "href": "02_getting_started_with_r.html#writing-our-own-functions",
    "title": "2  Getting Started with R",
    "section": "2.8 Writing our own functions",
    "text": "2.8 Writing our own functions\nFunctions, as you may remember, are objects that store commands. The three basic parts of a function are name, code to implement, and arguments. To assemble these parts, we can use the function() function (yes, really) followed by a pair of curly brackets {}:\n\nmy_function &lt;- function() {}\n\nfunction() will run the code that we write inside the curly brackets. This code is called the body of the function. Let’s try something simple, like adding 1 + 1:\n\nsimple_function &lt;- function() {\n    1 + 1 # This function is very simple\n}\n\n\n\n\n\n\n\nIndents make code more readable\n\n\n\nIndenting the body of the function helps the reader notice that the code is only supposed to run inside the function. Indentation doesn’t affect our functions, but it is helpful and widespread among R coders.\n\n\nTo run our function, we have to write its name followed by round brackets, just like with any other function:\n\nsimple_function()\n\n[1] 2\n\n\nRemember to write the round brackets even if they are empty. The round brackets make R run the code inside the function. If we don’t write these brackets, R will show us the code inside the function (try it!).\nLet’s write a function to convert Fahrenheit degrees to Celsius. We want to use this function with different temperatures, so we need to include an argument that will tell R which temperature to convert each time.\n\nfahr_to_cels &lt;- function(temperature) {\n    (temperature - 32) / 1.8\n}\nfahr_to_cels(27)\n\n[1] -2.777778\n\n\nNow let’s try something a bit more complicated: solving a quadratic equation. If we have an equation of the form \\(ax^2 + bx + c = 0\\), then the solutions are given by \\(x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\). We can write a function that will apply this formula for us.\n\nsolve_quadratic &lt;- function(a, b, c) {\n    # Quadratic equations can have two solutions\n    solution_1 &lt;- (-b + sqrt(b**2 - 4*a*c)) / 2*a # First solution\n    solution_2 &lt;- (-b - sqrt(b**2 - 4*a*c)) / 2*a # Second solution\n}\n\nNow all we need is to identify values of \\(a, b,\\) and \\(c\\) to pass as arguments.\n\nsolve_quadratic(a = 1, b = -1, c = -3)\n\nWhy didn’t our function show a result? When we run a function, R runs the code in the body and returns the result of the last line of code. In solve_quadratic(), the last line saves the second solution but doesn’t show it. We need more code to ensure that the last line displays both solutions. Since we are using a script (right?), it is easy add one more line to our function:\n\nsolve_quadratic &lt;- function(a, b, c) {\n    # Quadratic equations can have two solutions\n    solution_1 &lt;- (-b + sqrt(b**2 - 4*a*c)) / 2*a # First solution\n    solution_2 &lt;- (-b - sqrt(b**2 - 4*a*c)) / 2*a # Second solution\n    c(solution_1, solution_2) # Show vector of solutions\n}\nsolve_quadratic(a = 1, b = -1, c = -3)\n\n[1]  2.302776 -1.302776\n\n\nA more explicit way of ensuring our function will display its result is to use the return() statement inside the function:\n\nsolve_quadratic &lt;- function(a, b, c) {\n    # Quadratic equations can have two solutions\n    solution_1 &lt;- (-b + sqrt(b**2 - 4*a*c)) / 2*a # First solution\n    solution_2 &lt;- (-b - sqrt(b**2 - 4*a*c)) / 2*a # Second solution\n    return(c(solution_1, solution_2)) # Return vector of solutions\n}\nsolve_quadratic(a = 1, b = -1, c = -3)\n\n[1]  2.302776 -1.302776\n\n\nreturn() can appear anywhere in the body and the function output will still be whatever return() contains. Note that running return(solution_1, solution_2) will produce an error because the result of a function must always be a single object. This is why we combined both solutions from solve_quadratic() into a single vector.\nOur function can have as many arguments as we like. It is enough to add their names, separated by commas, in the parentheses that follow the function. When the function runs, R will replace each argument name in the function body with the corresponding value that we supply. If we don’t supply a value, R will replace the argument name with the argument’s default value (if we defined one).\nWe can also use our functions to create other functions. Imagine that we want to multiply the solutions to our equation by an arbitrary value (maybe because we want to convert the units of \\(x\\) to something else). And let’s pretend that, by default, we want to double the solutions. We can write another function that first calls solve_quadratic() and then multiplies the result by our arbitrary number.\n\nmultiply_solutions = function(a, b, c, multiplier = 2) {\n    solve_quadratic(a, b, c) * multiplier\n}\nmultiply_solutions(a = 1, b = -1, c = -3)\n\n[1]  4.605551 -2.605551\n\nmultiply_solutions(a = 1, b = -1, c = -3, multiplier = 10)\n\n[1]  23.02776 -13.02776\n\n\n\n\n\n\n\n\nObjects created in functions disappear\n\n\n\nAll of the objects that we create inside a function will disappear after it finishes running. Only the output will remain, and to save it we need to assign it to an object.\n\n\nBeing able to write our own functions is great, but we don’t need to reinvent the wheel every time we need to do something that is not available in R’s default version. We can easily download packages from CRAN’s online repositories to get many useful functions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#acquiring-external-packages",
    "href": "02_getting_started_with_r.html#acquiring-external-packages",
    "title": "2  Getting Started with R",
    "section": "2.9 Acquiring external packages",
    "text": "2.9 Acquiring external packages\nTo install a package from CRAN, we can use the install.packages() function. For example, if we wanted to install the package readxl (for loading .xslx files), we would need:\n\ninstall.packages(\"readxl\", dependencies = TRUE)\n\nThe argument dependencies tells R whether it should also download other packages that readxl needs to work.\nR may ask you to select a CRAN mirror which, simply put, refers to the location of the servers you want to download from. Choose a mirror close to where you are.\nAfter installing a package, we need to load it into R before we can use its functions. To load the package readxl, we need to use the function library(), which will also load any other packages required to load readxl and may print additional information.\n\nlibrary(\"readxl\")\n\nWhenever we start a new R session we need to load the packages we need. If we try to run a function without loading its package first, R will not be able to find it and will return an error message.\nWriting all our library() statements at the top of our R scripts is almost always good because it helps us know that we need to load the libraries at the start our sessions. It also lets others know quickly that they will need to have those libraries installed to be able to use our code.\nA library can contain many objects, but sometimes we only need one or two of its functions. To avoid loading the entire library, we can access the specific function directly by specifying the package name followed by two colons and then the function name. For example:\n\nreadxl::read_xlsx(\"fake_data_file.xlsx\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#exercise",
    "href": "02_getting_started_with_r.html#exercise",
    "title": "2  Getting Started with R",
    "section": "2.10 Exercise",
    "text": "2.10 Exercise\nLet’s try to practice all of the basic features of R that you just learned. Write a function that can simulate the roll of a pair of six-sided dice (let’s call them red and blue) an arbitrary number of times. This function should return a vector with the values of the red die that were strictly larger than the corresponding values of the blue die. Hint: to simulate rolling a die, you can use the function sample().\n\n\n\n\n\n\nExercise step by step\n\n\n\n\n\n\nStep 1: define a function that takes one argument, num_rolls, representing the number of times to roll the dice.\nStep 2: create two objects called red and blue to store the results from the dice rolls.\nStep 3: simulate the dice rolls using function sample() (read its help page if you need to).\nStep 4: create a vector of indices that identifies the values in the red die that were larger than the values in the blue die.\nStep 5: use this vector of indices to extract the values from the red die.\nStep 6: make sure that your function returns the values you extracted in step 5.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#footnotes",
    "href": "02_getting_started_with_r.html#footnotes",
    "title": "2  Getting Started with R",
    "section": "",
    "text": "** also works for exponentiation, but it’s better to stick to ^.↩︎\nThis output should show 6 names instead of 3. I can not fix the output in the notes, but the code works fine inside RStudio.↩︎\nYoung reader, this square is a floppy disk; not-so-young reader, I feel your pain.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  },
  {
    "objectID": "03_data_in_r.html",
    "href": "03_data_in_r.html",
    "title": "3  Data in R",
    "section": "",
    "text": "3.1 Data types\nData types are classifications of data that help R conform to our intuition: multiplying \\(2\\) by \\(7\\) feels right; multiplying “pineapple” by “stalactite” does not. R has data types double, integer, logical, character, complex, and raw, each with its own rules for storing and handling. Learning these rules now will allow us to analyze data later with less effort and fewer mistakes.\nData type complex is for imaginary numbers, and type raw is for raw bytes of data. It is unlikely that you will ever need these data types, so I will not explain them in these notes.\nDoubles are regular numbers with a decimal value (which may be zero). In general, R will save any number that we type as a double.\nmy_double &lt;- 5\ntypeof(my_double)\n\n[1] \"double\"\nIntegers are numbers that have no decimal component. To create an integer you must type a number followed by an L:\nmy_integer &lt;- 5L\ntypeof(my_integer)\n\n[1] \"integer\"\nMany data scientists ignore integers because we can save them as doubles. But R stores integers more precisely and with less memory than doubles. This extra efficiency is helpful when the computations are lengthy or imprecise, or when computer memory is limited.\nLogicals are truth values TRUE and FALSE, which are useful when we compare numbers or objects:\nmy_comparison &lt;- -3 &lt; 1\ntypeof(my_comparison)\n\n[1] \"logical\"\nThere is also a special type of logical value called NA, which denotes a missing value.\nmissing_value &lt;- NA\ntypeof(missing_value)\n\n[1] \"logical\"\nTreating NA as a logical value allows R to handle missing data in intuitive ways. Consider, for example, that if a value is missing, we cannot know whether it is bigger than a number, or whether it is equal to a word. R reflects this intuition by forcing any comparison involving NA to result in another NA.\nNA &gt; 5\n\n[1] NA\n\nNA == \"Sancho\"\n\n[1] NA\nCharacters are text like “hello”, “Elvis”, or “Somewhere in La Mancha”; or symbols that we want to handle as text, like “size 45” or “mail/u”. We can create a character object by typing a character or string of characters surrounded by quotes:\nmy_character &lt;- \"Somewhere in La Mancha\"\ntypeof(my_character)\n\n[1] \"character\"\nIt is easy to confuse character strings with objects because both look like chunks of text in the code. the_thing and \"the_thing\", for example, look alike. But the_thing is the name of an object that can contain any type of data, while \"the_thing\" is a piece of data that we can assign to any name. If we forget the quotation marks when writing a name, R will look for an object that likely doesn’t exist and will return an error.\nnoquotes\n\nError: object 'noquotes' not found\nAlso, notice that R will treat anything surrounded by quotation marks as a character string—regardless of what is between the quotes.\nnums_as_chars &lt;- \"-5 + 71\"\ntypeof(nums_as_chars)\n\n[1] \"character\"\nStill, we can identify strings because R always shows them surrounded by quotation marks and in a color different from other data types.\ntypeof(\"9\")\n\n[1] \"character\"\n\ntypeof(9)\n\n[1] \"double\"\nA special type of character string is a factor, which stores categorical information like color or degree of agreement. Factors can only have certain values called “levels”, which may be ordered (e.g., “agree”, “neutral”, “disagree”) or disordered (e.g., “red” or “green”). To create a factor, we can start with a vector of strings and use function as.factor() to convert it to a factor.\nmy_factor &lt;- as.factor(\"red\")\nmy_factor\n\n[1] red\nLevels: red\nThey may seem pointless now, but factors will matter more after we understand the different ways that R can group and organize data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data in R</span>"
    ]
  },
  {
    "objectID": "03_data_in_r.html#data-types",
    "href": "03_data_in_r.html#data-types",
    "title": "3  Data in R",
    "section": "",
    "text": "Write TRUE and FALSE explicitly\n\n\n\nAt the beginning of every session, R saves T and F as shortcuts for TRUE and FALSE. But T and F are not reserved words; they are regular objects that we can modify and even delete inadvertently. Fixing an accidental misuse of T or F will cost you more time and effort than whatever you may save by typing a single letter instead of a full word. So, I strongly suggest you always write TRUE and FALSE explicitly.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data in R</span>"
    ]
  },
  {
    "objectID": "03_data_in_r.html#data-structures",
    "href": "03_data_in_r.html#data-structures",
    "title": "3  Data in R",
    "section": "3.2 Data structures",
    "text": "3.2 Data structures\nData structures are ways of organizing data that make it easier for us to manipulate and understand it. I will explain five different data structures, each with its own advantages and limitations: atomic vectors, matrices, arrays, lists, and data frames.\n\n3.2.1 Atomic vectors\nAtomic vectors are the most basic type of data structure. They are one-dimensional groups of data where all values must be of the same type. There is only one exception: any vector can include NA as a value regardless of the type of the other values. This internal consistency of vectors makes it easy for us to store values that are supposed to describe the same property.\nTo create an atomic vector, we can group values using the combine function c():\n\nquijote_characters &lt;- c(\"Don Quijote\", \"Sancho Panza\", NA)\n\nAtomic vectors can have almost1 as many elements as you want (including zero).\n\n# length() counts the number of elements in the vector\nlength(quijote_characters)\n\n[1] 3\n\nlength(c())\n\n[1] 0\n\n\n\n\n\n\n\n\nCoercion\n\n\n\nAdding different data types to the same atomic vector does not produce an error. Instead, R automatically follows specific rules to coerce everything inside the vector to be of the same type. If a character string is present in an atomic vector, R will convert all other values to character strings. If a vector only contains logical values and numbers, R will convert the logicals to numbers; every TRUE becomes a 1, and every FALSE becomes a 0. The only values that are not coerced are NAs.\nFollowing these rules helps preserve information. It is easy, for example, to recognize the original types of strings \"TRUE\" and \"3.14\", or to transform a vector of 1s and 0s back to TRUEs and FALSEs.\n\n\n\n\n3.2.2 Matrices\nMatrices are two-dimensional “sheets” of data. To create a matrix, first give matrix() an atomic vector to reorganize into a matrix. Then, define the number of rows using the nrow argument, or the number of columns using the ncol argument. matrix() will reshape your vector into a matrix with the specified number of rows (or columns).\n\nscores_vec &lt;- c(-27, 2, 2, 14, -28, 35, 8, 13, 4)\nscores_mat &lt;- matrix(data = scores_vec, nrow = 3)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27   14    8\n[2,]    2  -28   13\n[3,]    2   35    4\n\n# Equivalently\nscores_mat &lt;- matrix(data = scores_vec, ncol = 3)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27   14    8\n[2,]    2  -28   13\n[3,]    2   35    4\n\n\nLike atomic vectors, matrices can have any data type, but only one (or NA).\n\ncharacter_mat &lt;- matrix(\n    data = c(\"Mario\", \"Peach\", \"Luigi\", \"Yoshi\"), \n    ncol = 2\n)\ncharacter_mat\n\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nBy default matrix() will fill up the matrix column by column. But we can fill the matrix row by row if we include the argument byrow = TRUE:\n\nscores_vec &lt;- c(-27, 2, 2, 14, -28, 35, 8, 13, 4)\nscores_mat &lt;- matrix(data = scores_vec, nrow = 3, byrow = TRUE)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27    2    2\n[2,]   14  -28   35\n[3,]    8   13    4\n\n\nWhen showing a matrix, R shows expressions with square brackets (e.g., [,1]). The numbers inside the square brackets are positional indices that denote the “coordinates” of the matrix. Two-dimensional objects like matrices have two indices. The first index always refers to the row, and the second always refers to the column. So, as with vectors, we can use square bracket notation [ ] to extract values from matrices.\n\nscores_mat[c(1, 3), 2] # Rows 1 and 3 in column 2\n\n[1]  2 13\n\n\nWe can even extract entire rows or columns.\n\nscores_mat[2,] # Extract entire second row\n\n[1]  14 -28  35\n\nscores_mat[, 1] # Extract entire first column\n\n[1] -27  14   8\n\n\n\n\n\n\n\n\nMatrices are fancy vectors\n\n\n\nDeep down, R thinks of a matrix as a vector folded to look like a square. That means, among other things, that you can reference an element of a vector with a single positional index. Check what happens if you run scores_mat[5].\n\n\nWe can define names for the rows and the columns of a matrix using the rownames() and colnames() functions.\n\nrownames(scores_mat) &lt;- c(\"Andrew\", \"Booker\", \"Comstock\")\ncolnames(scores_mat) &lt;- c(\"Columbia\", \"Rapture\", \"Atlantic\")\nscores_mat\n\n         Columbia Rapture Atlantic\nAndrew        -27       2        2\nBooker         14     -28       35\nComstock        8      13        4\n\n\nNow we can use these names to extract values:\n\nscores_mat[\"Andrew\", c(\"Rapture\", \"Columbia\")]\n\n Rapture Columbia \n       2      -27 \n\n\nThere are several useful functions to do matrix operations. For example:\n\nt(scores_mat) # Transpose the matrix\ndiag(scores_mat) # Extract values in diagonal\nscores_mat + scores_mat # Matrix addition\nscores_mat * scores_mat # Element-wise multiplication\nscores_mat %*% scores_mat # Matrix multiplication\n\n\n\n3.2.3 Arrays\nAn array is a multidimensional object that stacks groups of data. Using 1 dimension in an array forms a column of data with multiple values; using 2 dimensions is like a sheet of paper with several columns of data; 3 dimensions are like a book with several sheets; 4 dimensions are like a box with several books, and so on. Note that layers of an array have consistent sizes. All books have the same number of sheets, and all sheets have the same number of rows and columns.\nWe can use array() to create an n-dimensional array. The first argument in array() must be a vector with the values that we want to store in the array. The second argument must be a vector where the length denotes the number of dimensions, and the values denote the size of each dimension.\n\n# This is an array with 3 matrices, each with 2 rows and 2 columns\narray(c(25:28, 35:38, 45:48), dim = c(2, 2, 3))\n\n, , 1\n\n     [,1] [,2]\n[1,]   25   27\n[2,]   26   28\n\n, , 2\n\n     [,1] [,2]\n[1,]   35   37\n[2,]   36   38\n\n, , 3\n\n     [,1] [,2]\n[1,]   45   47\n[2,]   46   48\n\n\nThe dim argument works from the inside out. The first value is the number of elements in each column, the second value is the number of columns, the third element is the number of matrices, and so on.\nNote that the total number of elements in the array is equal to multiplying the sizes of all dimensions. If the vector we use to build the array has a different number of elements, R will discard or recycle values from the vector. Check it yourself.\n\n\n\n\n\n\nApplied inception\n\n\n\nTry to make an array with 4 dimensions. Following the metaphor from above, try to make an array with 3 books, each of which has 4 sheets with 2 columns and 2 rows each. See a quick solution below.\n\n\nCode\narray(c(1:48), dim = c(2, 2, 4, 3))\n\n\n\n\nVectors, matrices, and arrays need all of its values to be of the same type. This requirement seems severe, but it allows the computer to store large sets of numbers in a simple and efficient way; and it accelerates computations because it tells R that it can manipulate all values in the object in the same way.\nHowever, we often need to store different types of data in a single place—maybe because all the data belong to the same underlying subject of study. For example, we can describe a dog based on its height, weight, and age (numerical values), and on its color and breed (character strings or factors). R can keep all this information in a single place.\n\n\n3.2.4 Lists\nLists can group R objects like vectors, arrays, and other lists in a set of one dimension. To create a list, use the function list() and separate each of its elements with a comma.\n\nall_in_one_list &lt;- list(c(3.1, 10), \"El Zorro\", list(character_mat))\nall_in_one_list\n\n[[1]]\n[1]  3.1 10.0\n\n[[2]]\n[1] \"El Zorro\"\n\n[[3]]\n[[3]][[1]]\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nThe double-bracketed indices tell you which element of the list is displayed. The single-bracketed indices tell you which subelement of an element is displayed. For example, 3.1 is the first subelement of the first element in the list, and \"El Zorro\" is the first subelement of the second element. This double notation helps us recognize which level of the stacking we are in, regardless of what we stack inside the list.\nThere are two ways to access an element from a list, depending on what we want to do with the output. We can use single-bracket notation [ ] to get a new list with elements from the original list:\n\nnew_list &lt;- all_in_one_list[1]\nnew_list\n\n[[1]]\n[1]  3.1 10.0\n\ntypeof(new_list)\n\n[1] \"list\"\n\n\nOr we can use double-bracket notation [[ ]] to get only the subelements of an element from the original list (we cannot extract multiple elements this way).\n\nnew_item &lt;- all_in_one_list[[1]]\nnew_item\n\n[1]  3.1 10.0\n\ntypeof(new_item)\n\n[1] \"double\"\n\n\nWe can name the elements of a list when we first create it:\n\ncountries_info &lt;- list(\n    countries = c(\"Japan\", \"Egypt\", \"Mexico\", \"Finland\"),\n    temperatures_fahrenheit = c(50, 90, 65, -10),\n    speak_spanish = c(FALSE, FALSE, TRUE, FALSE)\n)\n\nOr we can name them after creating the list using names():\n\nnames(all_in_one_list) &lt;- c(\"weight\", \"hero\", \"game\")\nall_in_one_list\n\n$weight\n[1]  3.1 10.0\n\n$hero\n[1] \"El Zorro\"\n\n$game\n$game[[1]]\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nWith a named list, we can also use dollar sign notation $ to extract elements. This notation produces the same result as using the double bracket notation [[ ]]\n\ncountries_info$speak_spanish\n\n[1] FALSE FALSE  TRUE FALSE\n\ncountries_info[[\"speak_spanish\"]]\n\n[1] FALSE FALSE  TRUE FALSE\n\n\n\n\n3.2.5 Data frames\nData frames are the most common storage structure for data analysis. We can think of them as a group of atomic vectors (columns) of the same length. Usually, each row of a data frame represents an individual observation and each column represents a different measurement or variable of that observation.\nDifferent vectors in a data frame can have different data types, but they must all have the same length. If we use vectors of different lengths, R will recycle values of the shorter vectors to ensure that the data frame has a square shape.\nWe can create a data frame using the data.frame() function. Give data.frame() any number of vectors of equal length, each separated with a comma. It is usually convenient to set each vector equal to a name that describes the vector. data.frame() will turn each vector into a column of the new data frame:\n\naliens_df &lt;- data.frame(\n    name = c(\"Bender\", \"Fry\", \"Nibbler\", \"Zoidberg\"),\n    species = c(\"Robot\", \"Human\", \"Nibblonian\", \"Decapodian\"), \n    fingers_per_hand = c(3, 4, 3, NA)\n)\naliens_df\n\n      name    species fingers_per_hand\n1   Bender      Robot                3\n2      Fry      Human                4\n3  Nibbler Nibblonian                3\n4 Zoidberg Decapodian               NA\n\n\nWe can use the function dim() to get the size of each dimension of the data frame, and the function str() to get a compact summary:\n\ndim(aliens_df)\n\n[1] 4 3\n\nstr(aliens_df)\n\n'data.frame':   4 obs. of  3 variables:\n $ name            : chr  \"Bender\" \"Fry\" \"Nibbler\" \"Zoidberg\"\n $ species         : chr  \"Robot\" \"Human\" \"Nibblonian\" \"Decapodian\"\n $ fingers_per_hand: num  3 4 3 NA\n\n\nAs you can see, str() gives us the data frame dimensions, reminds us that aliens_df is of type data.frame, lists the names and data types of all of the variables (columns) contained in the data frame, and prints the first five values.\nTo us, a data frame resembles a matrix, but to R it is a list with an attribute “class” set to “data.frame”\n\ntypeof(aliens_df)\n\n[1] \"list\"\n\nclass(aliens_df)\n\n[1] \"data.frame\"\n\n\nThis means that we can extract extract values from data frames the same way we extract from lists. We can use single brackets [] to get a new data frame:\n\naliens_df[2]\n\n     species\n1      Robot\n2      Human\n3 Nibblonian\n4 Decapodian\n\n# Equivalently\naliens_df[\"species\"]\n\n     species\n1      Robot\n2      Human\n3 Nibblonian\n4 Decapodian\n\n\nOr we can use double brackets [[ ]] or dollar sign notation $ to get atomic vectors:\n\naliens_df$name\n\n[1] \"Bender\"   \"Fry\"      \"Nibbler\"  \"Zoidberg\"\n\n\nAlso, as with matrices, we can use a single bracket with two indices (note that this produces an atomic vector):\n\naliens_df[c(1,2), \"fingers_per_hand\"]\n\n[1] 3 4\n\n\nCreating data frames from scratch is cumbersome and prone to errors. In the next section, we will see how to import data from different sources into R, as well as basic ways to prepare it for analysis.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data in R</span>"
    ]
  },
  {
    "objectID": "03_data_in_r.html#references",
    "href": "03_data_in_r.html#references",
    "title": "3  Data in R",
    "section": "3.3 References",
    "text": "3.3 References\nMost of this section is based on “Hands-On Programming with R”, by Garret Grolemund; and on “An Introduction to R”, by Alex Douglas, Deon Roos, Francesca Mancini, Ana Couto & David Lusseau.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data in R</span>"
    ]
  },
  {
    "objectID": "03_data_in_r.html#footnotes",
    "href": "03_data_in_r.html#footnotes",
    "title": "3  Data in R",
    "section": "",
    "text": "The maximum length (number of elements) of a vector is \\(2^{31} - 1 \\approx 2*10^9\\). Run help(.Machine) in your R console to learn more about this.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Data in R</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html",
    "href": "04_basic_data_processing.html",
    "title": "4  Basic data processing",
    "section": "",
    "text": "4.1 Loading data\nOnce we can locate files in our computer, we can load them into R. Note, however, that we need specific ways to open different file formats.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#loading-data",
    "href": "04_basic_data_processing.html#loading-data",
    "title": "4  Basic data processing",
    "section": "",
    "text": "4.1.1 Plain text files\nA plain-text file stores a table of data in a text document. Each row of the table is saved in its own line, and a simple symbol separates the cells within a row. This symbol is most often a comma, and sometimes a tab or a pipe delimiter |, but it can also be any other character. Each file only uses one symbol to separate cells, which minimizes confusion.\nPlain-text files are simple and many programs can read them. This is why many organizations (e.g., the Census Bureau and the Social Security Administration) publish their data as plain-text files.\nWe will work with data fromthis1 plain text file. Use Ctrl+Shift+s to download the file. I will save it in a folder called “data_files” inside my working directory under the name “flower.csv”. You can save it wherever you want as long as you can keep track of it.\n\n4.1.1.1 read.table\nread.table() can load plain-text files. The first argument of read.table() is a string with the name of our file (if it is in your working directory), or with the file path to our file (if it is not in our working directory).\n\nflower_df &lt;- read.table(\"data_files/flower.csv\", header = TRUE, sep = \",\")\n\nIn the code above, I added arguments header and sep. header tells R whether the first line of the file contains variable names instead of values; this will help us identify the variables in the data frame. sep tells R the symbol that the file uses to separate the cells; this will help us preserve the correct location of the data cells.\nOther useful arguments are skip and nrow. skip tells R to omit a specific number of lines before it starts reading values from the file. This argument is helpful when the file starts with text that is not part of the data set, or when we want to read only part of a data set. nrow tells R to only read a certain number of lines, starting from the top. Keep in mind that nrow does not count the header in the number of rows it reads.\n\nflower_df_chunk &lt;- read.table(\n    \"data_files/flower.csv\", \n    header = TRUE, \n    sep = \",\", \n    skip = 0, \n    nrow = 3\n)\nflower_df_chunk\n\n  treat nitrogen block height weight leafarea shootarea flowers\n1   tip   medium     1    7.5   7.62     11.7      31.9       1\n2   tip   medium     1   10.7  12.14     14.1      46.0      10\n3   tip   medium     1   11.2  12.76      7.1      66.7      10\n\n\nread.table() has other arguments that we can tweak. You can read more about them in the function’s help page.\n\n\n4.1.1.2 Shortcuts for read.table\nR has shortcut functions that call read.table() in the background with different default values for popular types of files:\n\nread.table is the general purpose read function.\nread.csv reads comma-separated values (.csv) files.\nread.delim reads tab-delimited files.\nread.csv2 reads .csv files with European decimal format.\nread.delim2 reads tab-delimited files with European decimal format.\n\n\n\n4.1.1.3 HTML links\nread.table() and its shortcuts allow us to load data files directly from a website. Instead of using the file’s path or name, we can directly use a web address in the file argument of the function. Make sure to use the web address that links directly to the file, not to a web page that has a link to the file.\n\n\n4.1.1.4 read.fwf\nA fixed-width file (.fwf) is a type of plain-text file that, instead of a symbol, uses its layout to separate data cells. Each row is still in a single line, and each column begins at a specific number of characters from the left-hand side of the document. To correctly position its data, the file adds an arbitrary number of character spaces between data entries.\nIf our flowers data came in a fixed-width file, the first few lines would look like this:\n\ntreat  nitrogen block  height  weight  leafarea  shootarea  flowers\ntip    medium   1      7.5     7.62    11.7      31.9       1\ntip    medium   1      10.7    12.14   14.1      46.0       10\ntip    medium   1      11.2    12.76   7.1       66.7       10\ntip    medium   1      10.4    8.78    11.9      20.3       1\ntip    medium   1      10.4    13.58   14.5      26.9       4\ntip    medium   1      9.8     10.08   12.2      72.7       9\n\nFixed-width files may be visually intuitive, but computers find them difficult to work with. This may explain why R has a function for reading fixed-width files, but not for creating or saving them.\nWe can read fixed-width files into R with the function read.fwf(). This function adds another argument to the ones from read.table(): widths, which should be a vector of numbers. Each ith entry of the widths vector should state the width (in characters) of the ith column of the data set.\n\n\n\n4.1.2 Excel files\nThe best way to load data from Excel files (.xlsx) is to first save these files as .csv or .txt files and then use read.table. Excel files can include multiple spreadsheets, macros, colors, dynamic tables, and other complicated features that make it difficult for R to read the files properly. Plain text files are simpler, so we can load and transfer them more easily.\nStill, it is possible to load Excel files if we really need to. R has no native way of loading these files, but we can use the package readxl, which works on Windows, OS X, and Linux. We install it using install.packages(\"readxl\") and then load it using library(readxl). Once we load the package, we can use the function read_excel() to load files of the type .xls and .xlsx (see help(\"read_excel\") for more information).\n\n\n4.1.3 Files from other programs\nAs with Excel files, I suggest that you first try to transform files from other programs to plain-text files. This transformation is usually the best way to verify that our data are transcribed properly.\nStill, sometimes we can’t transform the file to a plain-text format—maybe because we can’t access the program that created the file (e.g., SAS or SPSS). In these cases, we can resort to one of several libraries:\n\nhaven, for reading files from SAS, SPSS, and Stata.\nR.matlab for reading files for versions MAT 4 and MAT 5.\nforeign for reading minitab and Systat file formats. This library can also read files from SAS, SPSS, and Stata, but I prefer to use haven in these cases.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#cleaning-data",
    "href": "04_basic_data_processing.html#cleaning-data",
    "title": "4  Basic data processing",
    "section": "4.2 Cleaning data",
    "text": "4.2 Cleaning data\nOnce we load our data files as data.frames, we should verify that all of the information has an appropriate format. The process of identifying, removing, and correcting inaccurate information is often referred to as “data cleaning”. We will practice data cleaning using a “messy” version of the flower data that we loaded above. You can get this messy version from here. Again, you can use Ctrl+Shift+s to download the file.\nSince this is a .csv file, we can load it using:\n\nflower_messy_df = read.csv(\"data_files/flower_messy.csv\", header = TRUE)\n\nFirst, we should ensure the column names follow the rules we saw in section 1. This will facilitate accessing the data in the columns later. We can check these column names using the colnames() function:\n\ncolnames(flower_messy_df)\n\n[1] \"Treat\"      \"Nitrogen\"   \"block\"      \"Height\"     \"Weight\"    \n[6] \"leaf.area\"  \"shoot.area\" \"FLOWERS\"   \n\n\nIf we opened the data file using something like Excel or Notepad, we would see that the names for columns 6 and 7 had blank spaces inside it. When loading the data, read.csv() automatically substitutes these blank spaces with periods ., so that the names conform to R’s conventions. read.csv() is pretty good at checking column names and other things, but it’s not perfect. So, it’s always a good idea to double-check everything ourselves.\nThe column names of flower_messy_df are legible, but we don’t want to struggle with their mix of upper and lower-case letters. Let’s rewrite all the names in lower case, which is quick and easy if we use tolower().\n\nnew_colnames &lt;- tolower(colnames(flower_messy_df)) # Modify column names\nnew_colnames\n\n[1] \"treat\"      \"nitrogen\"   \"block\"      \"height\"     \"weight\"    \n[6] \"leaf.area\"  \"shoot.area\" \"flowers\"   \n\n\nThese new column names are better, but we still need to change them inside flower_messy_df. Before moving on, let’s create a new data set called flower_clean_df.\n\nflower_clean_df &lt;- flower_messy_df\n\nUsing a copy of the original data set makes it easier to track our changes because we can always look back at the original version. It also eases backtracking when we make a mistake because we don’t have to reload our original data (which can take a long time with large files).\nNow we can use our improved column names.\n\ncolnames(flower_clean_df) &lt;- new_colnames # Replace column names in data frame\ncolnames(flower_clean_df) # Verify replacement\n\n[1] \"treat\"      \"nitrogen\"   \"block\"      \"height\"     \"weight\"    \n[6] \"leaf.area\"  \"shoot.area\" \"flowers\"   \n\n\nThe last change to these column names will be to substitute the periods with underscores. In R, this is purely out of personal preference, but it’s a good excuse to meet gsub(), which substitutes patterns of strings:\n\ncolnames(flower_clean_df) &lt;- gsub(\n    pattern = \"\\\\.\", # What we want to remove\n    replacement = \"_\", # What we want to have instead\n    x = colnames(flower_clean_df) # The object we want to modify\n)\ncolnames(flower_clean_df)\n\n[1] \"treat\"      \"nitrogen\"   \"block\"      \"height\"     \"weight\"    \n[6] \"leaf_area\"  \"shoot_area\" \"flowers\"   \n\n\nNote that I had to use \"\\\\.\" instead of simply \".\" to match the period. The reason is that gsub() interprets \".\" as saying “match any character”. This may sound silly but it helps when working with regular expressions —a syntax to find many different, complicated patterns in strings. Regular expressions are too complicated to explain here, but if you expect to work with text data regularly, I encourage you to learn more about them.\nWith our improved column names it will be easier to focus on giving every column an appropriate format: numbers should be of type “double” or “integer”, and text should be of type “character” or “factor”. Let’s check the types of the columns in our current data set.\n\nstr(flower_clean_df)\n\n'data.frame':   96 obs. of  8 variables:\n $ treat     : chr  \"tip\" \"tip\" \"tip\" \"tip\" ...\n $ nitrogen  : chr  \"medium\" \"medium\" \"medium\" \"Medium\" ...\n $ block     : int  1 1 1 1 1 1 1 1 2 2 ...\n $ height    : num  7.5 10.7 11.2 10.4 10.4 9.8 6.9 9.4 10.4 12.3 ...\n $ weight    : num  7.62 12.14 12.76 8.78 13.58 ...\n $ leaf_area : num  11.7 14.1 7.1 11.9 14.5 12.2 13.2 14 10.5 16.1 ...\n $ shoot_area: num  31.9 46 66.7 20.3 26.9 72.7 43.1 28.5 57.8 36.9 ...\n $ flowers   : chr  \"\\\"1\\\"\" \"10\" \"10\" \"1\" ...\n\n\nColumn “flowers” seems to contain numbers but is classified as type “character”. The reason is that there are quotes around the first value in this column:\n\nhead(flower_clean_df[[\"flowers\"]])\n\n[1] \"\\\"1\\\"\" \"10\"    \"10\"    \"1\"     \"4\"     \"9\"    \n\n\nR recognizes that the value itself has quotes, so it adds a backslash \\ to differentiate them from the quotes it uses to print strings. Let’s remove these confusing quotes.\n\nflower_clean_df[\"flowers\"] &lt;- gsub(\n    pattern = \"\\\"\", # \\\" the backlash tells R to match quotes\n    replacement = \"\", # This is how we write \"nothing\"\n    x = flower_clean_df$flowers # x needs to be a vector, so use\n                                # double brackets or dollar sign\n)\nhead(flower_clean_df$flowers)\n\n[1] \"1\"  \"10\" \"10\" \"1\"  \"4\"  \"9\" \n\n\nNow we can coerce the column “flowers” to be of type “double”.\n\nflower_clean_df[\"flowers\"] &lt;- as.numeric(flower_clean_df$flowers)\ntypeof(flower_clean_df$flowers)\n\n[1] \"double\"\n\nhead(flower_clean_df$flowers)\n\n[1]  1 10 10  1  4  9\n\n\nColumns “treat” and “nitrogen” are of type character. This is not wrong, but they will be easier to handle if we convert them to factors.\n\nflower_clean_df[\"treat\"] &lt;- factor(flower_clean_df$treat)\nflower_clean_df[\"nitrogen\"] &lt;- factor(flower_clean_df$nitrogen)\nstr(flower_clean_df)\n\n'data.frame':   96 obs. of  8 variables:\n $ treat     : Factor w/ 2 levels \"notip\",\"tip\": 2 2 2 2 2 2 2 2 2 2 ...\n $ nitrogen  : Factor w/ 8 levels \"high\",\"High\",..: 7 7 7 8 7 7 8 7 7 7 ...\n $ block     : int  1 1 1 1 1 1 1 1 2 2 ...\n $ height    : num  7.5 10.7 11.2 10.4 10.4 9.8 6.9 9.4 10.4 12.3 ...\n $ weight    : num  7.62 12.14 12.76 8.78 13.58 ...\n $ leaf_area : num  11.7 14.1 7.1 11.9 14.5 12.2 13.2 14 10.5 16.1 ...\n $ shoot_area: num  31.9 46 66.7 20.3 26.9 72.7 43.1 28.5 57.8 36.9 ...\n $ flowers   : num  1 10 10 1 4 9 7 6 5 8 ...\n\n\nColumn “treat” looks fine, but column “nitrogen” looks suspicious. It is supposed to have only three levels (“low”, “medium”, and “high”), but its description counts eight. Let’s examine these levels:\n\nlevels(flower_clean_df$nitrogen)\n\n[1] \"high\"   \"High\"   \"HIGH\"   \"low\"    \"lOw\"    \"Low\"    \"medium\" \"Medium\"\n\n\nRemember that R is case sensitive, so it interprets each of spelling “high” and “low” as a different value. We can fix this using tolower() once more. Note that this will convert the “nitrogen” column back to a simple character type, so we have to reconvert it to factor.\n\nflower_clean_df[\"nitrogen\"] &lt;- tolower(flower_clean_df$nitrogen)\nflower_clean_df[\"nitrogen\"] &lt;- factor(flower_clean_df$nitrogen)\nlevels(flower_clean_df$nitrogen)\n\n[1] \"high\"   \"low\"    \"medium\"\n\n\nUnless I have a good reason not to, I usually transform all character columns to have only lower case letters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#data-summaries-and-visualizations",
    "href": "04_basic_data_processing.html#data-summaries-and-visualizations",
    "title": "4  Basic data processing",
    "section": "4.3 Data summaries and visualizations",
    "text": "4.3 Data summaries and visualizations\nNow that our data are clean, we can get more complete summaries to understand them better. Function summary() recognizes the type of each column and displays a convenient summary:\n\nsummary(flower_clean_df)\n\n   treat      nitrogen      block         height           weight      \n notip:48   high  :32   Min.   :1.0   Min.   : 1.200   Min.   : 5.790  \n tip  :48   low   :32   1st Qu.:1.0   1st Qu.: 4.475   1st Qu.: 9.027  \n            medium:32   Median :1.5   Median : 6.450   Median :11.395  \n                        Mean   :1.5   Mean   : 6.840   Mean   :12.155  \n                        3rd Qu.:2.0   3rd Qu.: 9.025   3rd Qu.:14.537  \n                        Max.   :2.0   Max.   :17.200   Max.   :23.890  \n   leaf_area       shoot_area        flowers      \n Min.   : 5.80   Min.   :  5.80   Min.   : 1.000  \n 1st Qu.:11.07   1st Qu.: 39.05   1st Qu.: 4.000  \n Median :13.45   Median : 70.05   Median : 6.000  \n Mean   :14.05   Mean   : 79.78   Mean   : 7.062  \n 3rd Qu.:16.45   3rd Qu.:113.28   3rd Qu.: 9.000  \n Max.   :49.20   Max.   :189.60   Max.   :17.000  \n\n\nNow let’s imagine we want to study the distribution of values for weight. We can use a histogram to check the shape of this distribution.\n\nhist(\n    flower_clean_df$weight, \n    breaks = 15,\n    xlim = c(5, 25),\n    xlab = \"Weight\",\n    main = \"Few weights are above 20\"\n)\n\n\n\n\n\n\n\n\nOr we can get a simpler description using a box plot.\n\nboxplot(\n    flower_clean_df$weight, \n    ylab = \"Weight\", \n    col = \"darkgreen\",\n    main = \"Most weights are between 9 and 15\"\n)\n\n\n\n\n\n\n\n\nA single box plot is less descriptive than a histogram. But it is easier to compare box plots to look for “big” differences between distributions. Let’s compare the distributions of height by nitrogen level:\n\nboxplot(\n    height ~ nitrogen,\n    data = flower_clean_df, \n    col = c(\"yellow\", \"blue\", \"pink\"),\n    main = \"No clear association between height and nitrogen\"\n)\n\n\n\n\n\n\n\n\nNow let’s investigate the relationship between shoot area and leaf area. And let’s check whether this relationship changes depending on the value of treat. We can use a scatter plot with shoot area and leaf area, and we can color each point by their treat value.\n\nplot(\n    x = flower_clean_df$leaf_area,\n    y = flower_clean_df$shoot_area, \n    col = flower_clean_df$treat,\n    main = \"Shoot area seems proportional to leaf area\",\n    xlab = \"Leaf area\",\n    ylab = \"Shoot area\"\n)\n# Add a legend to the plot\nlegend(\n    x = \"bottomright\", \n    legend = levels(flower_clean_df$treat), \n    col = 1:length(levels(flower_clean_df$treat)), \n    pch = 16\n)\n\n\n\n\n\n\n\n\nNow let’s see how frequently the values of nitrogen and treat combine with each other, but only for flowers with a leaf area greater than 13. We can use a mosaic plot for this.\n\nnitrogen_by_treat_table = xtabs(\n    formula = ~ nitrogen + treat,\n    data = flower_clean_df[which(flower_clean_df$leaf_area &gt; 13),]\n)\nnitrogen_by_treat_table\n\n        treat\nnitrogen notip tip\n  high      14  12\n  low        7   3\n  medium    10   7\n\nmosaicplot(nitrogen_by_treat_table, main = \"Nitrogen by treat table\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#success",
    "href": "04_basic_data_processing.html#success",
    "title": "4  Basic data processing",
    "section": "4.4 Success!",
    "text": "4.4 Success!\nDear reader, you are now a capable useR. I hope this humble introduction helps you learn more about many different topics in R. Be curious, be bold, and, above all, be patient. Rome wasn’t built in a day. Best of luck!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#references",
    "href": "04_basic_data_processing.html#references",
    "title": "4  Basic data processing",
    "section": "4.5 References",
    "text": "4.5 References\nThe subsection on loading data is based on “Hands-On Programming with R”, by Garret Grolemund; and on “An Introduction to R”, by Alex Douglas, Deon Roos, Francesca Mancini, Ana Couto & David Lusseau.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "04_basic_data_processing.html#footnotes",
    "href": "04_basic_data_processing.html#footnotes",
    "title": "4  Basic data processing",
    "section": "",
    "text": "You can find the original file here, courtesy of Douglas et al. (see references).↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic data processing</span>"
    ]
  },
  {
    "objectID": "02_getting_started_with_r.html#references",
    "href": "02_getting_started_with_r.html#references",
    "title": "2  Getting Started with R",
    "section": "2.11 References",
    "text": "2.11 References\nMost of this section is based on “Hands-On Programming with R”, by Garret Grolemund; and on “An Introduction to R”, by Alex Douglas, Deon Roos, Francesca Mancini, Ana Couto & David Lusseau.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started with R</span>"
    ]
  }
]