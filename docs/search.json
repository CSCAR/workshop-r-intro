[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "index.html#who-are-this-notes-for",
    "href": "index.html#who-are-this-notes-for",
    "title": "Introduction to R",
    "section": "Who are this notes for?",
    "text": "Who are this notes for?\nThis notes are a intended for anyone that wants to use R but has little or no experience using it, and little or no experience in programming."
  },
  {
    "objectID": "index.html#creation-of-this-document",
    "href": "index.html#creation-of-this-document",
    "title": "Introduction to R",
    "section": "Creation of this document",
    "text": "Creation of this document\nThese notes are published using Quarto. You can find the source code for these notes at https://github.com/CSCAR/workshop-r-intro.\nYou can switch between light and dark modes using the switch in the top left corner of the screen. Images are color-reversed in dark mode to reduce brightness. Move your mouse over an image (or press it if you are on a mobile device) to show it in its original colors. All images link to full-size versions that can show more detail."
  },
  {
    "objectID": "index.html#contact-information",
    "href": "index.html#contact-information",
    "title": "Introduction to R",
    "section": "Contact information",
    "text": "Contact information\n\nCSCAR\nhttp://cscar.research.umich.edu/\nConsulting for Statistics, Computing and Analytics Research (CSCAR) is a unit of the Office of the Vice President of Research at the University of Michigan. CSCAR offers U-M researchers guidance and training in data collection, management, and analysis; and in the use of technical software and advanced computing in research.\nWe offer free, one-hour consultations with graduate-level statisticians. To request an appointment, you can send an email to deskpeople@umich.edu, or you can fill this form. You can also walk-in for a consultation with one of our Graduate Student Research Assistants (GSRAs). They are available Monday through Friday, between 9am and 5pm (we close on Tuesdays between noon and 1pm). Or you can use this link to self-schedule an appointment with a GSRA at your own convenience.\nAll of our scheduled appointments can be either remote or in-person.\nCSCAR can also help with simple statistical questions through email. You can write to stats-consulting@umich.edu.\nIf you have any questions or comments about these notes, you can contact Abner Heredia Bustos (abnerhb@umich.edu)."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Introduction to R",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThese notes have evolved over the years thanks to Abner Heredia Bustos, Xiru Lyu, and Chris Andrews.\nThis material was created for use in workshops and short courses presented by faculty and staff from the Consulting for Statistics, Computing & Analytics Research (CSCAR) unit at the University of Michigan."
  },
  {
    "objectID": "01_the_r_environment.html#why-becoming-a-user",
    "href": "01_the_r_environment.html#why-becoming-a-user",
    "title": "1  The R Environment",
    "section": "1.1 Why becoming a useR?",
    "text": "1.1 Why becoming a useR?\n\n1.1.1 Price ($0) and availability\nR is free—as in “no money required”—and it runs on Windows, MacOS, and several Unix platforms.\n\n\n1.1.2 Easy and cool graphics\nWith R, you can make basic scatter plots or histograms with one or two lines of code (assuming your data has a nice format). And you can use the “grammar of graphics” to make incremental changes: add custom colors, change the size of the plot or its contents, or arrange several graphics in grids.\n\n\n1.1.3 Abundant statistical tools\nR offers many powerful tools to fit statistical models (both bayesian and frequentist), including:\n\nLinear and Generalized Linear Models\nSurvival analysis\nTime series analysis\nRandom and Mixed Effects Models (aka hierarchical models, aka multilevel models)\nClassification and Clustering\nSample Size and Power Calculations\nMultivariable analysis (FA, PCA, SEM, …)\n\n\n\n\n1.1.4 Constant expansion\nNew tools become available in R all the time. R is a full-fledged programming language that allows users to write their own functions. Also, all of R’s code is open source, which means that everyone can examine it and contribute to it. So, users constantly publish their own “packages” (ready-to-use tools), which expand R’s base capabilities. As of March 2019, users have contributed over 13,700 packages to Comprehensive R Archive Network (CRAN). Many of these packages perform complex statistical routines that are not (and may never be) available in other statistical software systems.\n\n\n1.1.5 Flexible interfaces\nIn Windows, there are several ways to use R. The standard R graphical unit interface (GUI) allows you to point and click to do many basic tasks. Another GUI is R Commander, developed by John Fox at McMaster University. R Commander displays the underlying R code for each analysis to help the user learn the programming language. Tinn-R is another GUI from Jose Claudio Faria.\nThese GUIs are friendly and easy to grasp if you’re a beginner. But to use all of R’s capabilities you will need to do more than point and click.\nA more complete way of using R is through an integrated development environment (IDE), which, in short, helps you code. The most popular IDE for R is RStudio, which organizes the user’s screen into panes that display scripts, objects, graphics, and the R console.\nIn these notes, we will use RStudio a lot. The goal is for you to start taking full advantage of R’s capabilities."
  },
  {
    "objectID": "01_the_r_environment.html#why-isnt-everyone-a-user",
    "href": "01_the_r_environment.html#why-isnt-everyone-a-user",
    "title": "1  The R Environment",
    "section": "1.2 Why Isn’t Everyone a UseR?",
    "text": "1.2 Why Isn’t Everyone a UseR?\n\n1.2.1 One and Only\nMany users of statistics only learn how to use one statistical software, often the one taught in their first statistics course. In the past, R was almost never this first language, but nowadays many schools are teaching how to use it.\n\n\n1.2.2 Hard to learn\nIt can take time to get comfortable and productive with R, especially if you have little coding experience. Typing commands explicitly is more difficult than pointing and clicking. Also, each package has its own rules to learn. You can find a lot of good help for popular packages written by professional developers, but not so much for smaller packages written by other common users. Worst of all, some of the messages R displays if you make a mistake are uninformative, so figuring out what went wrong can be difficult.\nBut don’t get frustrated! You don’t have to be an expert programmer to use R. The benefits are worth spending some time up front."
  },
  {
    "objectID": "01_the_r_environment.html#suggestions-for-learning-r",
    "href": "01_the_r_environment.html#suggestions-for-learning-r",
    "title": "1  The R Environment",
    "section": "1.3 Suggestions for Learning R",
    "text": "1.3 Suggestions for Learning R\n\nLearn interactively! Reading can help only so much. Most people learn R best by typing commands themselves.\nAsk other R users for help.\nLook at (and retype) lots of sample code. Experiment with modifications of the code. You won’t break R. You’ll see many examples in this workshop but there is much more online.\nDon’t worry about getting errors. Experienced R users make errors all the time. Besides, you can learn a lot from error messages.\nSome useful links are:\n\nhttps://www.r-project.org: The R Home page, the central webpage for the R project. Here you will find links for downloading R, downloading additional packages for R, and almost everything else that you would like to know about the software or the people behind it.\nhttps://cran.r-project.org/web/views/: Task views summarize the most important packages involved in a subject field or analysis type.\nhttps://journal.r-project.org: The R Journal\nhttps://stats.stackexchange.com: Cross-Validated\nhttps://www.r-bloggers.com\nhttps://stats.idre.ucla.edu/r/: Institute for Digital Research and Education at UCLA\nhttps://socialsciences.mcmaster.ca/jfox/: John Fox’s home page\nhttps://sas-and-r.blogspot.com/: Examples of code to perform same task in each language"
  },
  {
    "objectID": "01_the_r_environment.html#how-to-get-r",
    "href": "01_the_r_environment.html#how-to-get-r",
    "title": "1  The R Environment",
    "section": "1.4 How to get R",
    "text": "1.4 How to get R\nR is already installed on the lab workstations. The following information is useful if you need to install R on another machine.\nAt the R Project Web Page the most important link is at the left hand side of the screen, under the “Download” heading. Click on the CRAN link (Comprehensive R Archive Network), and, after you choose one of the U.S. mirrors, you will be taken to the page that you will use to download everything R-related.\nOnce you find the CRAN web page, take the following steps to obtain R:\n\nClick on “Download R for XXX” that best describes your operating system (Linux, OS X, Windows).\nWhen using Windows, click on the “base” subdirectory. This will allow you to download the base R packages.\nClick the “Download R 3.X.X for Windows” link. R is updated quite frequently. At the time of this printing, version 4.3.3 is available. Save the .exe file somewhere on your computer.\nDouble-click on the .exe file once it has been downloaded. A wizard will appear that will guide you through the setup of the R software on your machine.\nOnce you are finished, you should have an R icon on your desktop that gives you a shortcut to the R system. Double-click on this icon, and you are ready to go!\n\n\n1.4.1 How to get RStudio\nRStudio is already installed on the lab workstations. The following information is useful if you need to install RStudio on another machine.\nVisit https://www.posit.co and download the free desktop version of RStudio.\n\n\n1.4.2 Contributed Packages\nWhat exactly are “additional contributed packages”? R is an open source software environment, so users are free to explore the code behind the software and to write their own new code. Statisticians, researchers, and other users have written additional packages for R that perform complex analyses (and simple ones!). In order to use these packages and the functions within them, you first need to download them. Base R comprises many packages, but odds are that you will discover an uncommon analysis technique in your research that requires you to install an additional package that is not included by default.\nThese additional packages are usually found CRAN. However, there are other repositories as well (e.g., bioconductor, github)."
  },
  {
    "objectID": "02_getting_started_with_r.html#the-rstudio-interface",
    "href": "02_getting_started_with_r.html#the-rstudio-interface",
    "title": "2  Getting Started with R",
    "section": "2.1 The RStudio interface",
    "text": "2.1 The RStudio interface\nThe first screen we see in R should look like this:\n\n\n\nThe first screen we see when we open RStudio\n\n\nHere, there are three main window panes. The “Console” window is where we type the code to tell the computer to do stuff.\nThe “Environment-History-Connections” window has three tabs. “Environment” shows the objects that we have saved during our session (I will explain this soon); “History” shows a record of all the code we asked the computer to run; and “Connections”—which we will not use here—shows we the connections we have to remote databases.\nThe “Files-Plots-Packages” window has several tabs. “Files” shows us all the files in our current working directory, which is the default location where R will look for files we want to load and where it will put any files we save. “Plots” will display the plots we make in R. “Packages” shows us the packages installed in our computer and whether they are loaded in our current session. “Help” allows us to search and read the documentation for packages and functions. “Viewer” can display content that usually belongs to a web browser (i.e., html files).\nWe can tell R to do stuff by typing commands in the line that begins with &gt; in the console window. This line is called “command prompt”. Let’s begin with something simple:\n\n1 + 1\n\n[1] 2\n\n\nThe [1] that appears next to the result informs us that the line begins with the first value in the result. This information is helpful when we run commands that produce multiple values, like in this case:\n\n80:110\n\n [1]  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98\n[20]  99 100 101 102 103 104 105 106 107 108 109 110\n\n\nIf we type an incomplete command, R will assume that we are still writing and will show a +. This + is not an arithmetical operator; it’s a prompt for us to continue writing in the next line. The prompt will not go away unless we complete the command or we press the “Escape” key. For example:\n\n&gt; 42 -\n+\n+\n+ 1\n[1] 41\n\nIf R does not understand a command, it will display an error message.\n\n&gt; 7 % 2\nError: unexpected input in \"7 % 2\"\n&gt;"
  },
  {
    "objectID": "02_getting_started_with_r.html#using-r-as-a-calculator",
    "href": "02_getting_started_with_r.html#using-r-as-a-calculator",
    "title": "2  Getting Started with R",
    "section": "2.2 Using R as a Calculator",
    "text": "2.2 Using R as a Calculator\nR can perform basic arithmetic operations. Type the following expressions at the command prompt (the line that begins with &gt;) in the R console window.\n\n5 + 3\n\n[1] 8\n\n5 - 3\n\n[1] 2\n\n5*3\n\n[1] 15\n\n5/3\n\n[1] 1.666667\n\n\nR can also do exponentiation with ^ or **; modulus, also known as remainder from division, with %%; and integer division with %/%.\nIf we try to do shoddy math, R will inform us (but not necessarily with an error message):\n\n0/0\n\n[1] NaN\n\n-1/0\n\n[1] -Inf\n\n\nR also has logical operators that will return “TRUE” or “FALSE”.\n\n5 == 6\n\n[1] FALSE\n\n5 != 6\n\n[1] TRUE\n\n5 &lt; 6\n\n[1] TRUE\n\n\nR has “and” (&) and “or” (|) operators to combine multiple logical statements:\n\n(5 &lt; 6) & (7 == 8)\n\n[1] FALSE\n\n(5 &lt; 6) | (7 == 8)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nPractice\n\n\n\nThink of an integer, double it, add six, divide it in half, subtract the number you started with, and then square it. If your code is correct, the answer should be nine.\n\n\nBe careful of comparisons and floating point arithmetic:\n\n(.1 + .2) == .3\n\n[1] FALSE\n\n(.1 + .2) - .3\n\n[1] 5.551115e-17\n\n\n\nThis is not R’s fault. All computers have a limited space to store numbers and decimal positions. So, computers often use numbers with “hidden” decimals even when it looks like they use round numbers. For example, what we think of as 3 may actually be 3.000005. This is common enough to justify the R FAQ (7.31). To quote from “The Elements of Programming Style”, by Kernighan and Plauger: “10.0 times 0.1 is hardly ever 1.0.”\nBeing able to do these computations is good and all, but what happens if we want to use a result later without redoing the computation? R can save numbers (and more) using something called “objects”."
  },
  {
    "objectID": "02_getting_started_with_r.html#objects",
    "href": "02_getting_started_with_r.html#objects",
    "title": "2  Getting Started with R",
    "section": "2.3 Objects",
    "text": "2.3 Objects\nIn simple terms, an object is a named piece of information. A single number, a word, a plot, and a set of instructions can all be objects if we name them. The name allows us to access the piece of information whenever we want. To create an object, we must first choose a name, then type an arrow &lt;- (a “lower than” symbol &lt; followed by a “minus” sign -), and then write the value that we want to save.\n\nmy_object &lt;- 42\n\nAnother way of creating the object is to use the “equal to” sign = instead of the arrow.\n\nmy_object = 42\n\nIn this context, both &lt;- and = are acting as “assignment operators” because they assign the value 42 to the name my_object. In R, = has several uses, so if you want to avoid confusion, I suggest you use &lt;-. But you can pick whichever symbol you like the most as long as you are consistent.\nNow the environment window shows that there is an object called my_object, which we can access at anytime by typing its name.\n\nmy_object\n\n[1] 42\n\n\n\n\n\nThe environment pane with an object\n\n\nmy_object has a number as its value, so we can do mathematical operations with it.\n\nmy_object + 7\n\n[1] 49\n\nmy_object**my_object\n\n[1] 1.501309e+68\n\n\nWe can also create objects based on other objects.\n\na &lt;- 10\nb &lt;- a\na\n\n[1] 10\n\nb\n\n[1] 10\n\n\nBe careful with names. If we try to reuse a name, R will overwrite the previous object without notifying us in any way.\n\nc &lt;- 2\nc\n\n[1] 2\n\nc &lt;- 711\nc\n\n[1] 711\n\n\nHowever, if an object was the copy of another object, overwriting the original object does not affect the copy:\n\na &lt;- 10\nb &lt;- a\nb\n\n[1] 10\n\na &lt;- 5\nb\n\n[1] 10\n\n\nWe can use almost any name we want, but there are a few rules:\n\nNames can be a combination of letters, digits, period . and underscore _.\nNames can not include white spaces.\nIf a name starts with a period ., it can not be followed by a digit.\nNames can not start with a number or an underscore _.\nNames are case-sensitive (age, Age and AGE are three different variables).\nReserved words can not be used as variables (TRUE, FALSE, NULL, if, …).\n\nThere are also a few suggestions that will save you many hours of frustration:\n\nAvoid giving your object the same name as a built-in function.\nIf you need to create objects with multiple words in their name, separate them with [an underscore] (my_value) or a dot (my.value), or capitalize the different words (MyValue). I like the underscore format (called snake case naming). You can use whichever one you want. Just be consistent.\nUse informative names. It is quick and easy to use names like x or my_value. But your code will be easier and faster to understand if your objects have names that illustrate what you want to do with them. Your colleagues and your future self will really appreciate it."
  },
  {
    "objectID": "02_getting_started_with_r.html#using-functions",
    "href": "02_getting_started_with_r.html#using-functions",
    "title": "2  Getting Started with R",
    "section": "2.4 Using functions",
    "text": "2.4 Using functions\nR has many built-in functions for anything from basic math to text manipulation to advanced statistical models. Functions are also objects in R. But instead of storing a single number as we did before, functions store commands that we can apply to an input. For example, we can round a number, calculate its square root, its factorial, or its natural logarithm. To use a function, we must write the name of a function followed by the data we want it to use inside a pair of round brackets.\n\nround(2.1415)\nsqrt(9)\nfactorial(7)\nlog(100)\n\nThe information inside the round brackets is called an “argument”. sqrt() and factorial() only use one argument (the number that we want to use). But other functions—like round() and log()—can take more arguments to modify their behavior. For example, in round(), the first argument corresponds to the number we want to round, and the second argument corresponds to the number of decimal places that we want to keep. The arguments are separated by commas.\n\nround(2.1415, 0)\n\n[1] 2\n\nround(2.1415, 2)\n\n[1] 2.14\n\n\nThe order of the arguments is important. What happens if we try to run round(2, 2.1415)? Fortunately, arguments have names that you can use to specify which data to use in each case. So, we can write\n\nround(x = 2.1415, digits = 3)\n\n[1] 2.142\n\n\nEven better, we can pass arguments in any order as long as we name them all\n\nround(digits = 3, x = 2.1415)\n\n[1] 2.142\n\n\nBut if we use the wrong name in a function, we will probably get an error message\n\nround(x = 2.1415, basket = 3)\n\nError in round(x = 2.1415, basket = 3): unused argument (basket = 3)\n\n\nA quick way to check what arguments we can use is to use another function called args(), which takes the name of a function as its argument:\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nThe output shows that round() has two arguments: x (the number we want to round) and digits. It also shows that digits is already set to zero. This means that R will use 0 as the default value. Arguments with default values are optional because we can choose to modify them or not.\nI encourage you to name all the arguments in the function, or at least the ones after the first argument. It is hard to remember all the arguments that can go into more complicated functions. And it is even harder to remember the correct order. Accidentally switching unnamed arguments can produce wrong results without us knowing. Naming the arguments will prevent errors and clarify the function’s behavior.\nWe can also use functions inside other functions\n\nsqrt(round(16.483, digits = 0))\n\n[1] 4\n\n\nR first runs the innermost function and then uses the result in the outermost function to get the final result.\nThe functions we have used are simple and intuitive to use. But sometimes we need to know more before we can use a function in our code. Where can we find explanations to help us?"
  },
  {
    "objectID": "02_getting_started_with_r.html#getting-help",
    "href": "02_getting_started_with_r.html#getting-help",
    "title": "2  Getting Started with R",
    "section": "2.5 Getting help",
    "text": "2.5 Getting help\nTo access R’s built-in help information on any function simply use the help() function. For example, to open the help page for round(), we do\n\nhelp(\"round\")\n\nA shorter way of writing this is to use ? before the name of the function.\n\n?round\n\nAfter you run the code, the help page is displayed in the “Help” tab in the “Files-Plots-Packages” pane (usually in the bottom right of RStudio).\nAs a novice user, help pages may seem arcane, probably because they aim for shortness and use a lot of technical jargon. But this short jargon makes (most of) the explanations precise, so we can use the information we need without having to read the entire document. Also, all help pages are organized similarly, so we don’t have to relearn how to navigate them. So, with a bit of practice, you will be able to find exactly what you need in mere seconds.\nThe first line of the help document displays the name of the function and the package that contains the function. Other sections are:\n\nDescription: a short description of the function.\nUsage: names the arguments associated with the function and possible default values.\nArguments: expounds each argument and what they do.\nDetails: a more detailed description of the function.\nValue: if applicable, gives the type and structure of the object returned by the function or the operator.\nSee Also: leads to other help pages with similar or related content.\nExamples: code examples on how to use the function. To see how they work, we just need to copy and paste them into the console. We can also access examples at any time by using the example() function (e.g., example(\"round\")).\n\nThe help() function is useful if we know the name of the function. But if all we remember is a key word in the name, we can search through R’s help system using help.search()\n\nhelp.search(\"round\")\n\nOr we can use the shortcut ??\n\n??round\n\nAs before, the ‘Help’ tab in RStudio will display the results of the search. help.search() searches through the help documentation, code demonstrations, and package vignettes and displays the results as clickable links that we can follow.\nAnother useful function is apropos(), which lists all functions containing a specified character string. For example, to find all functions with sum in their name, we use\n\napropos(\"round\")\n\n[1] \"round\"        \"round.Date\"   \"round.POSIXt\"\n\n\nNote that apropos() returns names even when the word we used is only part of a larger word, like in “surround”.\nIf we find the function we need, we can look for its documentation.\n\nhelp(\"round.Date\")\n\nAnother useful function is RSiteSearch(), which allows us to search for keywords and phrases in function help pages and vignettes for all CRAN packages, and in CRAN task views. This way we can access the online search engine directly from the Console and display the results in our web browser.\n\nRSiteSearch(\"regression\")\n\n\n\n\n\n\n\nHow to get started with help pages?\n\n\n\nStart by reading the help pages of functions that you already understand. This will teach you how to understand the structure of the pages and will familiarize you with the jargon. As you use R you will likely need other, more complicated functions, so reading more help pages will happen almost naturally.\nJust keep in mind that help pages are about code, not about the underlying concepts. If you don’t know what it means to round a number, reading the documentation for round() will not help you.\n\n\nNow that we know how to get help, we can move on to more advanced stuff. Previously we worked with one number at the time. But we can also work with groups of numbers (and of other stuff) by using something called “vectors”."
  },
  {
    "objectID": "02_getting_started_with_r.html#working-with-vectors",
    "href": "02_getting_started_with_r.html#working-with-vectors",
    "title": "2  Getting Started with R",
    "section": "2.6 Working with vectors",
    "text": "2.6 Working with vectors\nIn R, an ordered group of numbers is called a vector. To create a vector of numbers, we need to use the function c() (short for “combine”). The arguments of c() are the numbers you want to use in the vector, in the order you want to use them.\n\nmy_vec &lt;- c(5, 3, 7, 1, 1, 8)\nmy_vec\n\n[1] 5 3 7 1 1 8\n\n\nVectors can also contain other types of data, like words:\n\nvector_of_words &lt;- c(\"monday\", \"lemon\")\nvector_of_words\n\n[1] \"monday\" \"lemon\" \n\n\nNote that we must enclose words in quotation marks to let R know that we want to use “monday” and “lemon” as values instead of the names of objects. Look at what happens if we forget the quotation marks:\n\nvector_of_words &lt;- c(monday, lemon)\n\nError in eval(expr, envir, enclos): object 'monday' not found\n\n\nLater on we will work more with vectors of words, but for now let’s focus on numerical vectors.\n\n2.6.1 Operations with numerical vectors\nR is a “vectorized” language, which means that it can often operate on an entire vector of numbers as easily as on a single number. All the logical and mathematical functions we used before work with vectors:\n\nmy_vec / 11\n\n[1] 0.45454545 0.27272727 0.63636364 0.09090909 0.09090909 0.72727273\n\nmy_vec &lt;= 7\n\n[1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\nlog(my_vec)\n\n[1] 1.609438 1.098612 1.945910 0.000000 0.000000 2.079442\n\nmy_vec*my_vec\n\n[1] 25  9 49  1  1 64\n\n\nIn the last example, R did not follow the rules of linear algebra to multiply two vectors. Instead, R used “element-wise execution”, which means that R applied the same operation to each member of the vector. For example, my_vec + 7 adds 7 to each number inside my_vec.\nWhen you use two vectors with the same number of elements for an operation, R will line up the vectors and perform a sequence of individual operations. For instance, in my_vec*my_vec, R multiplies the first element of vector 1 by the first element of vector 2, then the second element of vector 1 by the second element of vector 2, and so on, until all elements are multiplied. The result will be a new vector the same length as the first two.\nIf you give R two vectors of unequal lengths, it will repeat the shorter vector until it is as long as the longer vector, and then do the math.\n\nmy_vec * c(1, 2)\n\n[1]  5  6  7  2  1 16\n\n\nIf the length of the short vector does not divide evenly into the length of the long vector, R will do an incomplete repeat of the shorter vector and return a warning.\n\nmy_vec * c(1, 2, 3, 4)\n\nWarning in my_vec * c(1, 2, 3, 4): longer object length is not a multiple of\nshorter object length\n\n\n[1]  5  6 21  4  1 16\n\n\nRepeating the numbers of the vector is known as “vector recycling”, and it helps R do element-wise operations.\nElement-wise operations allow us to manipulate entire data variables rather than one element at a time. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\nR can also do vector and matrix multiplications, but we have to explicitly ask for them. For example, to get the inner product, we need the operator %*%. And to get the outer product, we need %o%. If you are not familiar with matrix operations, don’t worry. You won’t need them in these notes.\n\n\n2.6.2 Extracting elements\nWe can access specific elements of vectors using the square bracket [ ] notation. Write the name of the vector you want to extract from, followed by the square brackets with an index of the element you wish to extract. This index can be a position or the result of a logical test.\nTo extract elements based on their position we simply write the position inside the [ ]. To extract the 3rd value of my_vec, we use\n\nmy_vec[3]\n\n[1] 7\n\n\nWe can store this value in another object\n\nvalue_3 = my_vec[3]\n\nAnd we can extract multiple elements at the time by using a vector of indices inside the square brackets:\n\nmy_vec[c(1, 3, 5)]\n\n[1] 5 7 1\n\n\nOr we can use : notation. Remember that : helps us create a sequence of values. For example,\n\n3:6\n\n[1] 3 4 5 6\n\n\nSo,\n\nmy_vec[3:6]\n\n[1] 7 1 1 8\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, the positional index starts at 1, so to call the first element of a vector we need to use [1]. In most other programming languages (like Python and C++), the positional index starts at 0.\n\n\nAnother convenient way to extract elements from a vector is to use a logical expression as an index. For example, to extract all elements greater than 4 from my_vec, we do\n\nmy_vec[my_vec &gt; 4]\n\n[1] 5 7 8\n\n\nThis works because R uses element-wise operations even for logical statements. So, my_vec &gt; 4 asks if each item of my_vec meets the condition “greater than four” and returns the corresponding vector of TRUE and FALSE. Then, when we add this result to the square brackets, R examines each element of my_vec asking “should I extract this element?”. If the answer is TRUE, the value is extracted; if it’s FALSE, the value is ignored. Under the hood, my_vec &gt; 4 is equivalent to\n\nmy_vec[c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE)]\n\n[1] 5 7 8\n\n\nTwo useful functions to extract values of a vector are head(), which extracts the first few values of a vector; and tail(), which gives us the last few values of a vector. Try them yourself!\n\n\n2.6.3 Replacing elements\nWe can replace the elements of a vector by combining the square bracket notation with the assignment operator. For example, to replace the second element of my_vec, we do\n\nmy_vec[2] &lt;- 99\nmy_vec\n\n[1]  5 99  7  1  1  8\n\n\nTo replace multiple elements with the same value, say, elements 5 and 6, we do\n\nmy_vec[c(5, 6)] &lt;- 55\nmy_vec\n\n[1]  5 99  7  1 55 55\n\n\nR can also replace elements with an element wise operation:\n\nmy_vec[c(5, 6)] &lt;- c(100, 200)\nmy_vec\n\n[1]   5  99   7   1 100 200\n\n\nWhat happens if you try to replace two values with a vector that has three (or more) values?\nLogical expressions help us replace values that meet specific conditions without having to find them ourselves.\n\nmy_vec[my_vec &gt; 44] &lt;- -1\nmy_vec\n\n[1]  5 -1  7  1 -1 -1\n\n\n\n\n2.6.4 Reordering elements of vectors\nTo sort the elements of a vector from lowest to highest, we can use sort()\n\nmy_vec &lt;- sort(my_vec)\nmy_vec\n\n[1] -1 -1 -1  1  5  7\n\n\nIf we want to sort from highest to lowest, we need to set the optional argument decreasing to TRUE\n\nmy_vec &lt;- sort(my_vec, decreasing = TRUE)\nmy_vec\n\n[1]  7  5  1 -1 -1 -1\n\n\nAnother option is to first use sort() and then reverse the sorted vector using rev().\n\nmy_vec &lt;- rev(sort(my_vec))\n\nA more useful feature of vectors is that we can reorder their elements based on the values of other vectors. To show this, let’s first create a vector of countries and another vector with (my guess of) their typical daily temperatures in degrees Fahrenheit.\n\ncountries &lt;- c(\"Japan\", \"Egypt\", \"Mexico\", \"Finland\")\ntemperatures_fahrenheit &lt;- c(50, 90, 65, -10)\n\nNow imagine we want to order the vector of countries, going from coldest to hottest. The first step to reorder the countries is to use order() to create a new variable called “temperatures_ordered”.\n\ntemperatures_ordered &lt;- order(temperatures_fahrenheit)\ntemperatures_ordered\n\n[1] 4 1 3 2\n\n\nThis output says that the lowest value in temperatures_fahrenheit is in the fourth position, the second lowest value is on the first position, and so on. So, we can think of temperatures_ordered as a vector of positional indices of temperatures in ascending order. Now we can use these indices to reorder the vector of countries.\n\ncountries_ordered &lt;- countries[temperatures_ordered]\ncountries_ordered\n\n[1] \"Finland\" \"Japan\"   \"Mexico\"  \"Egypt\"  \n\n\nTa-da!\nThese vector manipulations can do more than dazzle your friends. Imagine you have a dataset with two columns of data and you want to sort each column. If you just use sort() on each column separately, the values of each column will become uncoupled from each other. By using order() on one column, a vector of positional indices is created of the values of the column in ascending order. Then we can use this vector as the index of elements on the second column, which will return a vector of values based on the first column.\nUntil now, the console satisfied all our coding needs. But if we wanted to reuse a command from before, we would have to either rewrite it from scratch, or look through our command history (in the “Environment-History-Connections” window)—a tedious task. Besides, once we close this session in RStudio, all of our work will be gone, like tears in the rain. It would be much better if we wrote our code in a place where we can easily review and modify it."
  },
  {
    "objectID": "02_getting_started_with_r.html#working-with-scripts",
    "href": "02_getting_started_with_r.html#working-with-scripts",
    "title": "2  Getting Started with R",
    "section": "2.7 Working with scripts",
    "text": "2.7 Working with scripts\nAn R script is a plain text file that we can use to save our code. I think the best way to code in R is to use a script, and I strongly suggest you always use one. A script helps us edit, proofread and reuse our code. It also allows us to save our code so we can share it with others or come back to it later. Also, it is cumbersome to write multi-line code in the console, but it is easy if we use a script.\nTo open a script, click on File &gt; New File &gt; R script in the menu bar on the upper left-hand side of the screen.\n\n\n\nA screen with a new script\n\n\nWe can run a line of code using the Run button. R will run whichever line of code your cursor is on. We can also run all of the code in the script by clicking the Source button that’s next to Run. I find that clicking buttons is slow, so I use a keyboard shortcut for running a line of code: Control + Enter in Windows and Linux; Command + Enter in Mac.\n\n\n\nButtons for running code\n\n\nTo save your script, you can click on the blue square1 right below the tab with the script name. The first time you save your script, R will ask you to choose a name and a location to save your file in. I strongly suggest that you pick a name and and a location that you will remember easily in the future.\nMoving forward, I will write all my code in a script and will assume you are doing so too. Trust me, it’s for your own benefit.\nNow that we know how to preserve our hard-obtained code, we can start doing more elaborate work. For example, if R doesn’t have a pre-made function to do what we need, we can write one ourselves and test it easily using a script."
  },
  {
    "objectID": "02_getting_started_with_r.html#writing-our-own-functions",
    "href": "02_getting_started_with_r.html#writing-our-own-functions",
    "title": "2  Getting Started with R",
    "section": "2.8 Writing our own functions",
    "text": "2.8 Writing our own functions\nFunctions, as you may remember, are objects that store commands. The three basic parts of a function are name, code to implement, and arguments. To assemble these parts, we can use the function() function (yes, really) followed by a pair of curly brackets {}:\n\nmy_function &lt;- function() {}\n\nfunction() will run the code that we write inside the curly brackets. This code is called the body of the function.\nLet’s try something simple, like adding 1 + 1:\n\nsimple_function &lt;- function() {\n    1 + 1\n}\n\n\n\n\n\n\n\nIndents make code more readable\n\n\n\nNote that I indented the body of the function. This indentation doesn’t affect our function, but it lets the reader know that the code is only supposed to run inside the function.\n\n\nTo run our function, we have to write its name followed by round brackets, just like with any other function:\n\nsimple_function()\n\n[1] 2\n\n\nRemember to write the round brackets even if they are empty. The round brackets make R run the code inside the function. If we don’t write these brackets, R will show us the code inside the function (try it!).\nNow let’s write a function that will convert Fahrenheit degrees to Celsius. Since we want to use this function with different temperatures, we need to include an argument that will tell R which temperature to convert each time.\n\nfahrenheit_to_celsius &lt;- function(temperature) {\n    (temperature - 32) / 1.8\n}\nfahrenheit_to_celsius(27)\n\n[1] -2.777778\n\n\nNow let’s try something a bit more complicated: solving a quadratic equation. If we have an equation of the form \\(ax^2 + bx + c = 0\\), then the solutions are given by \\(x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\). We can write a function that will apply this formula for us.\n\nsolve_quadratic = function(a, b, c) {\n    # Quadratic equations can have two solutions\n    solution_1 = (-b + sqrt(b**2 - 4*a*c)) / 2*a # First solution to equation\n    solution_2 = (-b - sqrt(b**2 - 4*a*c)) / 2*a # Second solution to equation\n}\n\nDid you see the comments I added? R will ignore everything that comes after a hashtag #. This # is known in R as commenting symbol because it allows us to comment our code. This way we can explain confusing chunks of code, or warn about potential problems.\nNow all we need is to identify values of \\(a, b,\\) and \\(c\\) to pass as arguments.\n\nsolve_quadratic(a = 1, b = -1, c = -3)\n\nWhy didn’t our function show a result? When we run a function, R runs the code in the body and returns the result of the last line of code. If this line doesn’t return a value, neither will our function. So, we have to write something to ensure that solve_quadratic() displays the solutions. Since we are using a script (right?) it is easy to go back to our function and just add one more line:\n\nsolve_quadratic = function(a, b, c) {\n    # Quadratic equations can have two solutions\n    solution_1 = (-b + sqrt(b**2 - 4*a*c)) / 2*a # First solution to equation\n    solution_2 = (-b - sqrt(b**2 - 4*a*c)) / 2*a # Second solution to equation\n    c(solution_1, solution_2) # Show vector of solutions\n}\nsolve_quadratic(a = 1, b = -1, c = -3)\n\n[1]  2.302776 -1.302776\n\n\nOur function can have as many arguments as we like. It is enough to add their names, separated by commas, in the parentheses that follow the function. When the function runs, R will replace each argument name in the function body with the corresponding value that we supply. If we don’t supply a value, R will replace the argument name with the argument’s default value (if we defined one).\nNow imagine that we want to multiply the solutions to our equation by an arbitrary value (maybe because we want to convert the units of \\(x\\) to something else). And let’s pretend that, by default, we want to double the solutions. We can write another function that first calls solve_quadratic() and then multiplies the result by our arbitrary number.\n\nmultiply_solutions = function(a, b, c, multiplier = 2) {\n    solve_quadratic(a, b, c) * multiplier\n}\nmultiply_solutions(a = 1, b = -1, c = -3)\n\n[1]  4.605551 -2.605551\n\nmultiply_solutions(a = 1, b = -1, c = -3, multiplier = 10)\n\n[1]  23.02776 -13.02776\n\n\n\n\n\n\n\n\nObjects created in functions disappear\n\n\n\nAll of the objects that we create inside a function will disappear after it finishes running. We can only save the output of the function by assigning it to an object."
  },
  {
    "objectID": "02_getting_started_with_r.html#exercise",
    "href": "02_getting_started_with_r.html#exercise",
    "title": "2  Getting Started with R",
    "section": "2.10 Exercise",
    "text": "2.10 Exercise\nLet’s try to practice all of the basic features of R that you just learned.\nWrite a function that can simulate the roll of a pair of six-sided dice (let’s call them red and blue) an arbitrary number of times. This function should return a vector with the values of the red die that were strictly larger than the corresponding values of the blue die. Hint: to simulate rolling a die, you can use the function sample()."
  },
  {
    "objectID": "02_getting_started_with_r.html#footnotes",
    "href": "02_getting_started_with_r.html#footnotes",
    "title": "2  Getting Started with R",
    "section": "",
    "text": "Young reader, this square is a floppy disk; not-so-young reader, I feel your pain.↩︎"
  },
  {
    "objectID": "03_data_in_r.html#data-types",
    "href": "03_data_in_r.html#data-types",
    "title": "3  Data in R",
    "section": "3.1 Data types",
    "text": "3.1 Data types\nData types are classifications of data that help R conform to our intuition. For example, multiplying numbers by each other feels right, but multiplying words by each other does not. There are different rules for storing and handling each of these types. And learning these rules will allow us to analyze data later with less effort and fewer mistakes.\nThere are six types of data in R: doubles, integers, logicals, characters, complex, and raw. Doubles are regular numbers with a decimal value (which may be zero). In general, R will save any number that you type in R as a double.\n\nmy_double &lt;- 5\ntypeof(my_double)\n\n[1] \"double\"\n\n\nIntegers are numbers that have no decimal component. To create an integer you must type a number followed by an L:\n\nmy_integer &lt;- 5L\ntypeof(my_integer)\n\n[1] \"integer\"\n\n\nIn data science, we often don’t need integers because we can save them as doubles. But R stores integers more precisely than doubles. So, integers are still helpful when dealing with complicated operations.\nLogicals are truth values TRUE and FALSE. R also has a type of logical value called NA, which denotes a missing value. We often have to work with logical values when we compare numbers or objects:\n\nmy_comparison &lt;- -3 &lt; 1\ntypeof(my_comparison)\n\n[1] \"logical\"\n\n\nIn most situations, R will assume that T and F are abbreviations of TRUE and FALSE. But not always, so I suggest you always write the full words.\nCharacters are text, like “hello”, “Elvis”, or “Somewhere in La Mancha”; or symbols we want to handle as text, like “size 45”, or “mail/u”. You can create a character vector by typing a character or string of characters surrounded by quotes:\n\nmy_character &lt;- \"Somewhere in La Mancha\"\ntypeof(my_character)\n\n[1] \"character\"\n\n\nAnything surrounded by quotes in R will be treated as a character string—regardless of what is between the quotes.\nIt is easy to confuse R objects with character strings because both appear as pieces of text in R code. For example, the_thing is the name of an R object named the_thing that contains data; but \"the_thing\" is a character string that contains the character the_thing, i.e., it is itself a piece of data. If we forget to use the quotation marks when writing a name, R will look for an object that likely doesn’t exist, so we will most likely get an error.\n\nnoquotes\n\nError in eval(expr, envir, enclos): object 'noquotes' not found\n\n\nWe can differentiate strings from real numbers because R always shows strings surrounded by quotation marks. And because in RStudio, strings have different colors from other data types.\n\ntypeof(\"9\")\n\n[1] \"character\"\n\ntypeof(9)\n\n[1] \"double\"\n\n\nA special type of character string is a factor. Factors are R’s way of storing categorical information, like color or level of agreement. They can only have certain values (e.g., “red” or “green”), and these values may have their own order (e.g., “agree”, “neutral”, “disagree”).\nR can also handle imaginary numbers (called complex) and raw bytes of data (called raw). It is unlikely that you will ever need to use these data types, so I will not explain them in these notes."
  },
  {
    "objectID": "03_data_in_r.html#data-structures",
    "href": "03_data_in_r.html#data-structures",
    "title": "3  Data in R",
    "section": "3.2 Data structures",
    "text": "3.2 Data structures\nData structures are ways of organizing data. They make it easier for us to manipulate and operate with data. Different data structures have different advantages and limitations.\n\n3.2.1 Atomic vectors\nAtomic vectors store values as one-dimensional groups. All the elements of an atomic vector must be of the same type of data, with one exception: any vector can include NA as a value regardless of the type of the other values. These vector are called “atomic” because we can think of them as the most basic type of data structure.\nTo create an atomic vector, we can group values using the combine function c():\n\nquijote_characters &lt;- c(\"Don Quijote\", \"Sancho Panza\")\n\nAtomic vectors can have almost1 as many elements as you want—including zero!\n\n# length() counts the number of elements in the vector\nlength(quijote_characters)\n\n[1] 2\n\nlength(c())\n\n[1] 0\n\n\n\n\n\n\n\n\nCoercion\n\n\n\nAdding different data types to the same atomic vector does not produce an error. Instead, R automatically follows specific rules to coerce everything inside the vector to be of the same type. If a character string is present in an atomic vector, R will convert all other values to character strings. If a vector only contains logicals and numbers, R will convert the logicals to numbers; every TRUE becomes a 1, and every FALSE becomes a 0.\nFollowing these coercion rules helps preserve information. It is easy, for example, to recognize the original type of strings \"TRUE\" and \"3.14\". Or to transform a vector of 0s and 1s back to TRUEs and FALSEs.\n\n\n\n\n3.2.2 Matrices\nA matrix stores values in a two-dimensional box. To create a matrix, first give matrix() an atomic vector to reorganize into a matrix. Then, define the number of rows using the nrow argument, or the number of columns using the ncol argument. matrix() will reshape your vector into a matrix with the specified number of rows (or columns).\n\nscores_vec &lt;- c(-27, 2, 2, 14, -28, 35, 8, 13, 4)\nscores_mat &lt;- matrix(data = scores_vec, nrow = 3)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27   14    8\n[2,]    2  -28   13\n[3,]    2   35    4\n\n# Equivalently\nscores_mat &lt;- matrix(data = scores_vec, ncol = 3)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27   14    8\n[2,]    2  -28   13\n[3,]    2   35    4\n\n\nLike atomic vectors, matrices can have any data type, but only one (or NA):\n\ncharacter_mat &lt;- matrix(\n    data = c(\"Mario\", \"Peach\", \"Luigi\", \"Yoshi\"), \n    ncol = 2\n)\ncharacter_mat\n\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nBy default matrix() will fill up the matrix column by column. But we can fill the matrix row by row if we include the argument byrow = TRUE:\n\nscores_vec &lt;- c(-27, 2, 2, 14, -28, 35, 8, 13, 4)\nscores_mat &lt;- matrix(data = scores_vec, nrow = 3, byrow = TRUE)\nscores_mat\n\n     [,1] [,2] [,3]\n[1,]  -27    2    2\n[2,]   14  -28   35\n[3,]    8   13    4\n\n\nWhen showing a matrix, R shows expressions with square brackets (e.g., [,1]). These are positional indices that denote the “coordinates” of the matrix. Two-dimensional objects like matrices have two indices, one for each dimension. The first number always refers to the row, and the second always refers to the column. So, as with vectors, we can use square bracket notation [ ] to extract values from matrices.\n\nscores_mat[c(1, 3), 2] # Rows 1 and 3 in column 2\n\n[1]  2 13\n\n\nWe can even extract entire rows or columns.\n\nscores_mat[2,] # Extract entire second row\n\n[1]  14 -28  35\n\nscores_mat[, 1] # Extract entire first column\n\n[1] -27  14   8\n\n\n\n\n\n\n\n\nMatrices are fancy vectors\n\n\n\nDeep down, R thinks of a matrix as a vector folded to look like a square. That means, among other things, that you can reference an element of a vector with a single positional index. Check what happens if you run scores_mat[5].\n\n\nWe can define names for the rows and the columns of a matrix using the rownames() and colnames() functions.\n\nrownames(scores_mat) &lt;- c(\"Andrew\", \"Booker\", \"Comstock\")\ncolnames(scores_mat) &lt;- c(\"Columbia\", \"Rapture\", \"Atlantic\")\nscores_mat\n\n         Columbia Rapture Atlantic\nAndrew        -27       2        2\nBooker         14     -28       35\nComstock        8      13        4\n\n\nNow we can use these names to extract values:\n\nscores_mat[\"Andrew\", c(\"Rapture\", \"Columbia\")]\n\n Rapture Columbia \n       2      -27 \n\n\nThere are several useful functions to do matrix operations. For example:\n\nt(scores_mat) # Transpose the matrix\ndiag(scores_mat) # Extract values in diagonal\nscores_mat + scores_mat # Matrix addition\nscores_mat * scores_mat # Element-wise multiplication\nscores_mat %*% scores_mat # Matrix multiplication\n\n\n\n3.2.3 Arrays\nThe array() function creates an n-dimensional array. Using an n-dimensional array is like stacking groups of data. 1 dimension forms a column of data with multiple values; 2 dimensions are like a sheet of paper with several columns of data; 3 dimensions are like a book with several sheets; 4 dimensions are like a box with several books; 5 dimensions are like room that contains boxes, and so on. Note that layers of an array have consistent sizes. All books have the same number of sheets, and all sheets have the same number of rows and columns.\nTo use array(), we need an atomic vector as the first argument, and a vector of dimension sizes dim as the second argument:\n\narray(c(25:28, 35:38, 45:48), dim = c(2, 2, 3))\n\n, , 1\n\n     [,1] [,2]\n[1,]   25   27\n[2,]   26   28\n\n, , 2\n\n     [,1] [,2]\n[1,]   35   37\n[2,]   36   38\n\n, , 3\n\n     [,1] [,2]\n[1,]   45   47\n[2,]   46   48\n\n\nThe dim argument works from the inside out. The first value is the number of elements in each column, the second value is the number of columns, the third element is the number of matrices, and so on.\nNote that the total number of elements in the array is equal to multiplying the sizes of all dimensions. If the vector we use to build the array has a different number of elements, R will discard or recycle values from the vector. Check it yourself.\n\n\n\n\n\n\nApplied inception\n\n\n\nTry to make an array with 4 dimensions. Following the metaphor from above, try to make a box that contains 3 books, each of which has 4 sheets with 2 columns and 2 rows each. See a quick solution below.\n\n\nCode\narray(c(1:48), dim = c(2, 2, 4, 3))\n\n\n\n\nVectors, matrices, and arrays need all of its values to be of the same type. This requirement seems rigid, but it allows the computer to store large sets of numbers in a simple and efficient way; and it accelerates computations because R knows that it can manipulate all values in the object the same way. Also, vectors make it easy for us to store values that are supposed to measure the same property. It would be hard to understand what a vector represented if it had values like \"salsa\" and sqrt(77).\nBut sometimes we need to store different types of data in a single place—maybe because all of that data belongs to the same underlying concept. For example, we can describe a dog based on its height, weight, and age (numerical values), and on its color and breed (character strings). R can keep all of these in a single place.\n\n\n3.2.4 Lists\nLists can group R objects like vectors, arrays, and other lists in a set of one dimension. To create a list, use the function list() and separate each element in the list with a comma.\n\nall_in_one_list &lt;- list(c(3.1, 10), \"El Zorro\", list(character_mat))\nall_in_one_list\n\n[[1]]\n[1]  3.1 10.0\n\n[[2]]\n[1] \"El Zorro\"\n\n[[3]]\n[[3]][[1]]\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nThe double-bracketed indices tell you which element of the list is displayed. The single-bracket indices tell you which subelement of an element is displayed. For example, 3.1 is the first subelement of the first element in the list, and \"El Zorro\" is the first subelement of the second element. This double notation helps us recognize which level of the stacking we are in, regardless of what we stack inside the list.\nThere are two ways to access an element from a list, depending on what we want to do with the output. We can use single bracket notation [ ] to get a new list with elements from the original list:\n\nnew_list &lt;- all_in_one_list[1]\nnew_list\n\n[[1]]\n[1]  3.1 10.0\n\ntypeof(new_list)\n\n[1] \"list\"\n\n\nOr we can use double bracket notation [[ ]] to get only the contents of an element from the original list (we can not extract multiple elements this way).\n\nnew_item &lt;- all_in_one_list[[1]]\nnew_item\n\n[1]  3.1 10.0\n\ntypeof(new_item)\n\n[1] \"double\"\n\n\nWe can name the elements of a list when we first create it:\n\ncountries_info &lt;- list(\n    countries = c(\"Japan\", \"Egypt\", \"Mexico\", \"Finland\"),\n    temperatures_fahrenheit = c(50, 90, 65, -10),\n    speak_spanish = c(FALSE, FALSE, TRUE, FALSE)\n)\n\nOr we can name them after the list is made using names():\n\nnames(all_in_one_list) &lt;- c(\"weight\", \"hero\", \"game\")\nall_in_one_list\n\n$weight\n[1]  3.1 10.0\n\n$hero\n[1] \"El Zorro\"\n\n$game\n$game[[1]]\n     [,1]    [,2]   \n[1,] \"Mario\" \"Luigi\"\n[2,] \"Peach\" \"Yoshi\"\n\n\nWith a named list, we can also use dollar sign notation $ to extract elements. This notation produces the same result as using the double bracket notation [[ ]]\n\ncountries_info$speak_spanish\n\n[1] FALSE FALSE  TRUE FALSE\n\ncountries_info[[\"speak_spanish\"]]\n\n[1] FALSE FALSE  TRUE FALSE\n\n\n\n\n3.2.5 Data frames\nData frames are the most common storage structure for data analysis. We can think of them as a group of atomic vectors (columns). Usually, each row of a data frame represents an individual observation and each column represents a different measurement or variable of that observation.\nDifferent vectors can have different data types, but they must have the same length. If we use vectors of different lengths, R will recycle values of some vectors to ensure that the data frame has a square shape.\nWe can create a data frame using the data.frame() function. Give data.frame() any number of vectors of equal length, each separated with a comma. Each vector should be set equal to a name that describes the vector. data.frame will turn each vector into a column of the new data frame:\n\naliens_df &lt;- data.frame(\n    name = c(\"Axanim\", \"Blob\", \"Cloomin\", \"Dlemex\"),\n    planet = c(\"Kepler-5\", \"Patzapuan\", \"Laodic_Prime\", \"Future_Earth\"), \n    number_of_arms = c(5, NA, 1, 2.5)\n)\naliens_df\n\n     name       planet number_of_arms\n1  Axanim     Kepler-5            5.0\n2    Blob    Patzapuan             NA\n3 Cloomin Laodic_Prime            1.0\n4  Dlemex Future_Earth            2.5\n\n\nWe can use the function dim() to get the size of each dimension of the data frame, and the function str() to get a compact summary:\n\ndim(aliens_df)\n\n[1] 4 3\n\nstr(aliens_df)\n\n'data.frame':   4 obs. of  3 variables:\n $ name          : chr  \"Axanim\" \"Blob\" \"Cloomin\" \"Dlemex\"\n $ planet        : chr  \"Kepler-5\" \"Patzapuan\" \"Laodic_Prime\" \"Future_Earth\"\n $ number_of_arms: num  5 NA 1 2.5\n\n\nThe str() function gives us the data frame dimensions and also reminds us that aliens_df is a data.frame type object. str() also lists all of the variables (columns) contained in the data frame, tells us what type of data the variables contain and prints out the first five values.\nTo us, a data frame resembles a matrix, but to R it is a list with an attribute “class” set to “data.frame”\n\ntypeof(aliens_df)\n\n[1] \"list\"\n\nclass(aliens_df)\n\n[1] \"data.frame\"\n\n\nAs with lists, we can extract extract values from data frames using single brackets [], which produce a new data frame:\n\naliens_df[2]\n\n        planet\n1     Kepler-5\n2    Patzapuan\n3 Laodic_Prime\n4 Future_Earth\n\n# Equivalently\naliens_df[\"planet\"]\n\n        planet\n1     Kepler-5\n2    Patzapuan\n3 Laodic_Prime\n4 Future_Earth\n\n\nOr we can use double brackets [[ ]] or dollar sign notation $, both of which produce atomic vectors:\n\naliens_df[[1]]\n\n[1] \"Axanim\"  \"Blob\"    \"Cloomin\" \"Dlemex\" \n\n\nAlso, as with matrices, we can use a single bracket with two indices (note that this produces an atomic vector):\n\naliens_df[c(1,2), \"number_of_arms\"]\n\n[1]  5 NA\n\n\nCreating data frames from scratch is cumbersome and prone to errors. In the next section, we will see how to import data from different sources into R, as well as basic ways to prepare it for analysis."
  },
  {
    "objectID": "03_data_in_r.html#references",
    "href": "03_data_in_r.html#references",
    "title": "3  Data in R",
    "section": "3.3 References",
    "text": "3.3 References\nMost of this section is based on “Hands-On Programming with R”, by Garret Grolemund; and on “An Introduction to R”, by Alex Douglas, Deon Roos, Francesca Mancini, Ana Couto & David Lusseau."
  },
  {
    "objectID": "03_data_in_r.html#footnotes",
    "href": "03_data_in_r.html#footnotes",
    "title": "3  Data in R",
    "section": "",
    "text": "The maximum length (number of elements) of a vector is 2^31 - 1 ~ 2*10^9. See here for more information.↩︎"
  },
  {
    "objectID": "04_basic_data_processing.html",
    "href": "04_basic_data_processing.html",
    "title": "4  Basic data processing",
    "section": "",
    "text": "Now that we understand how R handles data, we can start working with some"
  },
  {
    "objectID": "05_data_for_analysis.html#creating-data-random-numbers",
    "href": "05_data_for_analysis.html#creating-data-random-numbers",
    "title": "5  Data for Analysis",
    "section": "5.1 Creating Data: Random numbers",
    "text": "5.1 Creating Data: Random numbers\nR has excellent number generating capabilities. This makes R a good programming environment for simulation studies. The rnorm function randomly draws from a univariate normal distribution. (The ‘r’ stands for random.)\n&gt; rnorm(3)\n&gt; rnorm(3, mean=10, sd=0.5)\n&gt; x = rnorm(100, mean=10, sd=2)\n&gt; hist(x, col=\"blue\", main=\"100 Random Numbers from a Normal Distribution\")\nSee help(rnorm) for more details. You can generate from many distributions using functions such as rnorm, rt, rf, rbinom, runif, rexp, and rgamma.\n\n5.1.1 Functions about Probability Distributions\nR is also a source of exact probability tables and therefore eliminates the need to flip to the back of a statistics textbook to calculate probabilities under curves or critical values. For example, you can calculate the 95% critical value of a t distribution with 34 degrees of freedom with the following command:\n&gt; qt(0.975, df=34)\nWe can find the critical value of a standard normal distribution using qnorm. (The ‘q’ stands for quantile function.)\n&gt; qnorm(0.975)\nWe can also find cumulative probabilities needed for p-values. (The ‘p’ stands for probability function.)\n&gt; pnorm(-1.96)"
  },
  {
    "objectID": "05_data_for_analysis.html#reading-data-from-files",
    "href": "05_data_for_analysis.html#reading-data-from-files",
    "title": "5  Data for Analysis",
    "section": "5.2 Reading data from files",
    "text": "5.2 Reading data from files\nResearchers often analyze data that are stored in spread-sheet or text formats. The most common function to import data is read.table. Before looking at an example of how read.table is used, let’s consider common issues that arise when reading data into any program.\n\nWhat is the file name?\nWhat is the file type?\nWhere is the file located?\nDoes the file include variable names?\nHow are fields separated (e.g., tab, comma, white-space)?\nHow are missing values stored?\n\nThe read.table function is used in R for importing text data into data set objects. This function requires that you have a valid data table in a text format (where rows are observations, and columns are variables) with every cell containing a data point. If there are any blanks, the function may not work properly. Missing values by default should be coded as NA before attempting to import text data. Columns should be separated by white space.\nThe read.table function has arguments that allow the user to control data importation features.\n&gt; help(read.table)\nThe four most important arguments to the read.table function are file, header, sep, and na.strings. Let’s practice by importing the samp2.dat text file. Be sure to first change the working directory to the folder that contains samp2.dat. In RStudio you can either use the Session &gt; Set Working Directory menu option or use the setwd() function.\n&gt; gro = read.table(\"groceries.txt\")\n&gt; head(gro)\n&gt; str(gro)\nBy passing only the file argument to read.table, we have left all other arguments at their default values. Notice that R reads the variable names to be the first row of data rather than the column names. R has stored the columns of gro as a factor.\n&gt; gro = read.table(\"groceries.txt\", header=TRUE)\n&gt; head(gro)\n&gt; str(gro)\n&gt; tail(gro)\n&gt; summary(gro)\n&gt; dim(gro)"
  },
  {
    "objectID": "05_data_for_analysis.html#importing-from-excel",
    "href": "05_data_for_analysis.html#importing-from-excel",
    "title": "5  Data for Analysis",
    "section": "5.3 Importing from Excel",
    "text": "5.3 Importing from Excel\n“How do I import my data into R from Excel?” is a common question.\nMy answer is often: “Don’t!”\nExcel spreadsheets contain attributes and formatting that often cause difficulty when transferring files between applications. In particular, dates, or text that looks like dates, are troublesome. Zip codes and MRNs lose their leading zeros. The easiest thing to do is to first export the data into either a tab-delimited (.dat, .tsv) or comma separated values (.csv) file. After the file is in a more portable format, then use read.table or read.csv into R.\nWe use the samp2.csv file for practice.\n&gt; dat2 = read.csv(\"samp2.csv\", na.strings=c(NA, 88, 999))\n&gt; dat2\nread.csv simply invokes read.table with a different set of default arguments. Notice that the default for read.csv is to include a header.\n&gt; help(read.csv)\n\n5.3.1 Straight from Excel\nHowever it is possible to skip the .csv step using one of several R packages. Option 1: Use the Import Dataset button above the environment window in RStudio (obviously this only applies if using RStudio). Option 2: Use the read_excel function in the readxl package (actually, Option 1 uses Option 2). Option 3: use package xlsx. Option 4: ...\nThese approaches may result in slightly different data formats. This is not a problem, just be certain to investigate your data after loading."
  },
  {
    "objectID": "05_data_for_analysis.html#data-from-other-formats",
    "href": "05_data_for_analysis.html#data-from-other-formats",
    "title": "5  Data for Analysis",
    "section": "5.4 Data from other Formats",
    "text": "5.4 Data from other Formats\nR can read directly from other formats with varying levels of success. Functions exist for fixed width formats, .sas7bdat, SAS xport, SPSS, Stata, DBF, ..."
  },
  {
    "objectID": "05_data_for_analysis.html#exporting-data",
    "href": "05_data_for_analysis.html#exporting-data",
    "title": "5  Data for Analysis",
    "section": "5.5 Exporting Data",
    "text": "5.5 Exporting Data\nR has facilities for exporting data. Suppose you make changes to a data set within R and you want to save those changes permanently in a .csv or .xls file. The write.csv command exports an R object to a text file. All you have to do is give write.csv two arguments: 1) the R object to be exported, and 2) the name of the file.\nFor example, write.csv(M, \"newfile.csv\") will export the R object M to a newly created file newfile.csv. We will modify dat2 to include an id variable, and we write the updated data object to a csv file.\n&gt; dat2$id = 1:nrow(dat2)\n&gt; dat2\n&gt; write.csv(dat2, \"newfile.csv\")\nR can also write to text files using write.table."
  },
  {
    "objectID": "05_data_for_analysis.html#missing-values-in-data-files",
    "href": "05_data_for_analysis.html#missing-values-in-data-files",
    "title": "5  Data for Analysis",
    "section": "5.6 Missing Values in Data files",
    "text": "5.6 Missing Values in Data files\nData files can represent missing data in many ways. Often Excel files have blank cells. Text files may use a special value such as 999 to represent missingness. SAS uses a period. Different codes may specify different reasons for the missingness such as non-response or an unreasonable value.\nThere are several ways to convert these conventions to NA in R so they will (more likely) be treated properly in analyses. (There are entire statistics courses on “properly” dealing with missing data.)\nSuppose that the \\(88\\) and \\(999\\) are codes indicating missing values. We want R to interpret these values as missing rather than numeric. We can change these values to NA after reading in the data. First we identify them and then replace them by NA.\n&gt; dat = read.csv(\"samp2.csv\")\n&gt; dat\n&gt; dat$z == 88 | dat$z == 999\n&gt; dat$z[dat$z == 88 | dat$z == 999]\n&gt; dat$z[dat$z == 88 | dat$z == 999] = NA\n&gt; dat\n\n5.6.1 The which function\nWhile we are on the subject of missing data (NA) and logical values (TRUE, FALSE), I want to mention the which function. It statement takes a logical statement (or a series of logical statements, some which may be missing) as an argument. It returns the indices for which the logical statement is TRUE.\n&gt; a = c(6, 9, 10, 2, 999, NA)\n&gt; is.na(a)\n&gt; which(is.na(a))\n&gt; which(!is.na(a))\n&gt; a == 999\n&gt; a[a == 999]\n&gt; which(a == 999)\n&gt; a[which(a == 999)]\n&gt; a[which(a == 999)] = NA\n&gt; a\n&gt; is.na(a)\nThe which command is a very powerful tool for data management. Consider the following three scenarios:\n\nYou have a data set and wish to perform an analysis on only males.\nAll missing values have been coded as 99, 888, or 999.\nA scatterplot reveals several outliers, and you need to identify the cases corresponding to the outliers.\n\nIn each scenario, which can be used to select the appropriate subset of the data."
  },
  {
    "objectID": "06_student_t-tests.html#one-sample-t-test",
    "href": "06_student_t-tests.html#one-sample-t-test",
    "title": "6  Student t-tests",
    "section": "6.1 One-sample t-test",
    "text": "6.1 One-sample t-test\nClean up the workspace and import height.csv into R.\n&gt; rm(list=ls()) # removes all objects\n&gt; dat = read.csv(\"height.csv\", header=TRUE)\n&gt; head(dat)\nLet’s start with a one-sample t-test. Test the hypothesis that the population mean height for men is 70 inches (\\(H_0:\\mu_{men} = 70\\))\nFirst we need to get the subset where gender \\(==\\) male.\n&gt; dat$gender == \"male\"\n&gt; men.ht = dat$height[dat$gender == \"male\"]\nBefore doing any formal analyses, it is always a good idea to summarize the data both numerically and visually.\n&gt; summary(men.ht)\n&gt; boxplot(men.ht)\n&gt; hist(men.ht, main=\"My First Histogram in R!\")\nThe t.test function will perform a one sample t-test for the height of men. Suppose we wish to test the hypothesis \\(H_0: \\mu_{men} = 70\\) versus the alternative \\(H_a: \\mu_{men} \\neq 70\\). We must give the t.test function 1) the vector of male height values, and 2) the value of the mean under the null hypothesis. The default alternative is two-sided.\n&gt; t.test(men.ht, mu=70)\nWhat if you want to calculate a 90% confidence interval?\n&gt; help(t.test)\nThe conf.level argument will be used to change the confidence level.\n&gt; t.test(men.ht, mu=70, conf.level= 0.90)\n&gt; t.out = t.test(men.ht, mu=70, conf.level= 0.90)\n&gt; names(t.out)\n&gt; t.out$conf.int"
  },
  {
    "objectID": "06_student_t-tests.html#independent-samples-t-tests",
    "href": "06_student_t-tests.html#independent-samples-t-tests",
    "title": "6  Student t-tests",
    "section": "6.2 Independent Samples t-tests",
    "text": "6.2 Independent Samples t-tests\nNow suppose we wish to test whether there is a difference between the population mean heights for men and women (\\(H_0: \\mu_m = \\mu_w\\)). Before running the t-test, let’s make side-by-side boxplots to visually compare the heights of men and women.\n&gt; boxplot(men.ht, women.ht)\n\n6.2.1 The formula operator (\\(\\sim\\))\nIt is possible to avoid creating separate vectors for two groups that you would like to compare. This is done with the formula operator and many R functions can accept a formula as the first argument. The second argument must then nearly always be the data.frame where the formula should be evaluated.\n&gt; boxplot(height\\(\\sim\\)gender, data=dat)\nIf you don’t include the data argument, you’ll likely get an error message:\n&gt; boxplot(height\\(\\sim\\)gender) # error: data not found?\nThe variables in the dat data.frame can be made available temporarily by wrapping the command inside a call to with:\n&gt; with(dat, boxplot(height\\(\\sim\\)gender))\nIf you need access to the variables in a data.frame for an extended session and you aren’t going to change the variables in the data.frame, you can use the attach(dat) function to access height and gender directly. However, using attach is discouraged by some analysts. It puts a second copy of the data.frame on the “search path” and can make updating your data tricky. Remember to detach when you are done.\n&gt; height\n&gt; attach(dat)\n&gt; height\n&gt; detach(dat)\n&gt; height\nNow perform the independent samples t-test.\n&gt; t.test(height\\(\\sim\\)gender, data=dat)"
  },
  {
    "objectID": "07_chi-square_tests.html#goodness-of-fit",
    "href": "07_chi-square_tests.html#goodness-of-fit",
    "title": "7  Chi-Square tests",
    "section": "7.1 Goodness of Fit",
    "text": "7.1 Goodness of Fit\nSuppose a company wants to determine if employees are equally likely to call in sick on any day of the week. That is, test the hypothesis \\[H_0: p_1 = p_2 = p_3 = p_4 = p_5\\] where \\(p_1\\) represents the probability that a random call-in sick occurs on Monday, etc. The employer collects data and obtains the following table\n\n\n\n\nMon\nTue\nWed\nThu\nFri\n\n\n34\n18\n19\n12\n26\n\n\n\n\nIf \\(H_0\\) is true, the expected value in cell \\(i\\) is \\(E_i = np_i\\), where \\(n = 34 + 18 + 19 + 12 + 26 = 109\\) and \\(p_i = 0.2\\). The differences between the observed and expected values are combined into the \\(\\chi^2\\) statistic. \\[\\chi^2 = \\sum_i\\frac{(O_i - E_i)^2}{E_i}\\] If the null hypothesis is true, the \\(\\chi^2\\) statistic approximately follows a \\(\\chi^2(k-1)\\) distribution, where \\(k\\) is the number of groups (5). This approximation is poor if the expected value in any cell is small.\nWe first need to get the data into R.\n&gt; days = c(34, 18, 19, 12, 26)\n&gt; names(days) = c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\")\n&gt; days\nMany chi-square tests are performed using the chisq.test function.\n&gt; chisq.test(days)\nR returns the \\(\\chi^2\\) test statistic, the degrees of freedom, and the p-value. Notice that we didn’t specify that we were testing the hypothesis that were testing the hypothesis of equal probabilities. By default, chisq.test assumes a test of equal probabilities unless the user specifies otherwise. If, for some reason, we wanted to test the hypothesis that \\(p_1 = 0.35\\), \\(p_2 = 0.1\\), \\(p_3 = 0.1\\), \\(p_4 = 0.1\\), \\(p_5 = 0.35\\), we can do so by passing the probabilities to chisq.test in this way.\n&gt; chisq.test(days, p=c(0.35, 0.1, 0.1, 0.1, 0.35))\nSo far, the output for the chi-square tests have been limited. What if we wanted to obtain expected values or cell residuals? We unleash more of R’s capabilities by storing the value of the test as an object.\n&gt; cs.test = chisq.test(days)\n&gt; names(cs.test)\n&gt; cs.test$expected\n&gt; cs.test$statistic\n&gt; cs.test$residuals"
  },
  {
    "objectID": "07_chi-square_tests.html#chi-square-test-of-independence",
    "href": "07_chi-square_tests.html#chi-square-test-of-independence",
    "title": "7  Chi-Square tests",
    "section": "7.2 Chi-Square Test of Independence",
    "text": "7.2 Chi-Square Test of Independence\nA Chi-Square Test of Independence tests for a relationship between two categorical variables. We will use the “UCBAdmissions data set” to illustrate.\n&gt; data()\n&gt; UCBAdmissions\n&gt; class(UCBAdmissions)\n&gt; dim(UCBAdmissions)\nLet’s select the second 2 by 2 table to perform a chi-square test of independence.\n&gt; dat = UCBAdmissions[,,2]\n&gt; dat\nWhen we pass a vector of values to chisq.test, a test of homogeneity is performed by default. When we pass a table or matrix, a test of independence is performed.\n&gt; chisq.test(dat)\nThe default in R is to use Yates’ continuity correction for 2x2 tables. You can opt not to use it.\n&gt; chisq.test(dat, correct=FALSE)"
  },
  {
    "objectID": "07_chi-square_tests.html#fishers-exact-test",
    "href": "07_chi-square_tests.html#fishers-exact-test",
    "title": "7  Chi-Square tests",
    "section": "7.3 Fisher’s Exact Test",
    "text": "7.3 Fisher’s Exact Test\nPearson Chi-Square tests rely on an approximation that becomes poor as cell sizes get small. With smaller samples, Fisher’s Exact Test might be a good alternative. However, there are many flavors of Fisher’s test. R has implemented many of them, including one in the base package.\n&gt; fisher.test(dat)"
  },
  {
    "objectID": "08_linear_models.html#simple-linear-regression-using-the-lm-function",
    "href": "08_linear_models.html#simple-linear-regression-using-the-lm-function",
    "title": "8  Linear Models",
    "section": "8.1 Simple Linear Regression using the lm function",
    "text": "8.1 Simple Linear Regression using the lm function\nIn a simple linear regression, we propose the model: \\[Y = \\beta_0 + \\beta_1 X + \\epsilon,\\] where \\(Y\\) is the dependent variable, \\(X\\) is the sole independent variable, and \\(\\epsilon\\) represents a random component. One of the goals in a simple linear regression is to find the estimates, \\(\\hat{\\beta_0}\\) and \\(\\hat{\\beta_1}\\), that fit the data best.\nThe R function used to fit regression models is the lm function. Let’s begin by doing a simple linear regression of systolic blood pressure on diastolic blood pressure.\n&gt; lm(sbp\\(\\sim\\)dbp, data=dat)\nAt first glance, R returns the estimated regression parameters \\(\\hat{\\beta_0}\\) and \\(\\hat{\\beta_1}\\) but very little else. What about the model \\(r^2\\)? How do we find the residuals? What about confidence intervals, influential points, or the other diagnostics one should consider when performing a regression analysis?\nBy storing the fitted model as an object, we are able to unleash all the power in the lm function. Let’s try again, but this time, store the linear model as an object.\n&gt; mymod = lm(sbp\\(\\sim\\)dbp, data=dat)\nThe variable mymod now stores the information from the regression of sbp on dbp. mymod is a linear model object. Just as we earlier saw examples of numeric objects (x = 5) and character objects (y = \"Hi\"), we now have the object mymod which is a linear model object. Let’s verify that mymod is a linear model object.\n&gt; class(mymod)\nNow that we have the “lm\" object stored in mymod, let’s do some more investigation.\n&gt; summary(mymod)\nThe summary function returns the following\n\nA 5-number summary of the residuals\nA table of regression coefficients, standard errors, t-statistics, and p-values for testing the hypotheses that \\(\\beta_i = 0\\)\nAn estimate of the error standard deviation\nUnadjusted and adjusted model \\(r^2\\)\nAn overall F-test of no model effect\n\nWe can use the names function to see everything that is stored in mymod.\n&gt; names(mymod)\nWe can extract any single attribute using $.\n&gt; mymod$coefficients\n&gt; mymod$fitted.values\nR has many “extractor” functions:\n&gt; coef(mymod)\n&gt; fitted(mymod)\nR also has powerful graphing tools for checking model assumptions. For a simple linear regression, we need to check for\n\nThe nature of the relationship between \\(Y\\) and \\(X\\) (linear?)\nThe error distribution\nInfluential points\n\nUsing the plot function, we can cycle through diagnostic graphs to test each of the above assumptions.\n&gt; plot(residuals(mymod), predict(mymod), main=\"Residual Plot\")\nConfidence intervals for the regression coefficients provide much more information than p-values. Confidence intervals for \\(\\beta_0\\) and \\(\\beta_1\\) can be generated using the confint function.\n&gt; confint(mymod)\n&gt; confint(mymod, level=.90)\nWe can also examine the ANOVA table associated with the regression model.\n&gt; anova(mymod)"
  },
  {
    "objectID": "08_linear_models.html#analysis-of-variance",
    "href": "08_linear_models.html#analysis-of-variance",
    "title": "8  Linear Models",
    "section": "8.2 Analysis of Variance",
    "text": "8.2 Analysis of Variance\nSuppose one wishes to do a 2-way ANOVA model, where diastolic blood pressure is the response with gender and smoking status the two factors. As always, it is important to begin by investigating the relationships graphically.\n&gt; boxplot(dbp\\(\\sim\\)smoke, data=dat)\n&gt; boxplot(dbp\\(\\sim\\)gen, data=dat)\n&gt; with(dat, interaction.plot(smoke, gen, dbp))\nSince an ANOVA model is simply a linear model where the only predictors are dummy variables representing group membership, ANOVA models can be fit using the lm function.\n&gt; lm.mod = lm(dbp\\(\\sim\\)gen + smoke, data=dat)\n&gt; summary(lm.mod)\nMany researchers prefer output organized in a different ANOVA table. We can also use the aov function to fit an ANOVA model.\n&gt; aov.mod = aov(dbp\\(\\sim\\)gen + smoke, data=dat)\n&gt; summary(aov.mod)\nlm.mod and aov.mod represent the same fit but the summary function reports them differently. summary is an example of a generic function. Different versions are used for different classes. Remember that we used summary earlier to describe numeric vectors, factors, and data.frames. Let’s investigate the class of the two models.\n&gt; class(lm.mod)\n&gt; class(aov.mod)\nThe following commands give the mean of the dependent variable and each factor level:\n&gt; model.tables(aov.mod)\n&gt; ?model.tables\nWe can use Tukey’s HSD procedure to test the pairwise differences, adjusting for multiple testing:\n&gt; TukeyHSD(aov.mod)\n&gt; ?TukeyHSD"
  },
  {
    "objectID": "08_linear_models.html#multiple-linear-regression",
    "href": "08_linear_models.html#multiple-linear-regression",
    "title": "8  Linear Models",
    "section": "8.3 Multiple Linear Regression",
    "text": "8.3 Multiple Linear Regression\nA multiple linear regression assumes the following relationship: \\[Y = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + ... + \\beta_pX_p + \\epsilon\\] In this notation, \\(Y\\) represents the response variable of interest, and the \\(X_j\\) correspond to predictor variables. When fitting a linear regression model, one aim to estimate the \\(\\beta\\) parameters. The fitted model is sometimes used to predict future responses.\nWe will use the built-in LifeCycleSavings data set (which we saw in passing earlier) to illustrate fitting a multiple linear regression. We will use the popular car (Companion to Applied Regression) package for some regression diagnostics.\n&gt; data()\nLet’s first begin by learning about the data set.\n&gt; help(LifeCycleSavings)\nShorten the name.\n&gt; Life=LifeCycleSavings\nNow let’s make a boxplot of each of the five variables. For comparison, it would be helpful to view all of the plots on the same output. The par and mfrow commands are useful for this. The par function allows you to set graphical parameters, and mfrow allows you to specify an array of plots.\nThe following commands set up a two by two grid of plots.\n&gt; par(mfrow=c(2,2))\nWe can add boxplots one at a time.\n&gt; boxplot(Life$sr, main=\"sr\")\n&gt; boxplot(Life$pop15, main=\"pop15\")\n&gt; boxplot(Life$pop75, main=\"pop75\")\n&gt; boxplot(Life$dpi, main=\"dpi\")\nAfter exploring the marginal relationships of each of the variables, it is a good idea to investigate the bivariate relationships. We do this both numerically and graphically.\n&gt; cor(Life)\n&gt; pairs(Life, panel=panel.smooth)\nNow fit a multiple regression model using the lm function.\n&gt; mr.mod = lm(sr\\(\\sim\\)pop15 + pop75 + dpi + ddpi, data=Life)\n&gt; summary(mr.mod)\n&gt; confint(mr.mod)\nWe saw that there was a large negative correlation between pop75 and pop15. One diagnostic for multicolinearity is the variance inflation factor (VIF). Let’s investigate the variance inflation factors. It has been implemented in the car package. To access the function we must load the package:\n&gt; library(car)\n&gt; ?vif\n&gt; vif(mr.mod)\nHow does the model change if we leave out one of the variables? We fit a different model removing pop75.\n&gt; mr.mod2 = lm(sr\\(\\sim\\)pop15 + dpi + ddpi, data=Life)\nWe now perform an F test for nested models.\n&gt; anova(mr.mod, mr.mod2, test=\"F\")"
  },
  {
    "objectID": "09_lists.html#string-manipulation",
    "href": "09_lists.html#string-manipulation",
    "title": "9  Lists",
    "section": "9.1 String Manipulation",
    "text": "9.1 String Manipulation\nIn the third column of dat, systolic and diastolic pressure were placed together separated by a “/”. Ideally, data would never be stored in such a manner. For easy data processing, systolic and diastolic blood pressure should be stored in separate columns. Although in our data sets we did have separate columns, suppose for the sake of example that we only had the one column in which blood pressure was entered as \\(120/82\\). It could be time consuming to convert these to separate variables by hand in Excel.\nFortunately, R has excellent string manipulation facilities. In this example, we will use the strsplit function to extract diastolic and systolic blood pressures. strsplit has two arguments that we will use. The first argument is the character string we wish to split. The second argument is the character that we will split on. Let’s start with the bp value in the first row.\n&gt; b = dat$bp[1]\n&gt; b\nNow let’s try to split b into two separate values.\n&gt; strsplit(b, split=\"/\")\nThis didn’t work. When a problem like this arises, be sure to look at the error messages! In this example, R complains that we have a “non-character\" argument. Let’s investigate.\n&gt; class(b)\nSure enough, b is a factor since it was obtained by indexing a factor in the data set. We must first change b to a character.\n&gt; b = as.character(b)\n&gt; class(b)\nNow we are ready!\n&gt; strsplit(b, split=\"/\")\nThis seems to work, but in order to use the separated values, we must first store the split string as an object.\n&gt; sep = strsplit(b, split=\"/\")\n&gt; sep\n&gt; class(sep)"
  },
  {
    "objectID": "09_lists.html#lists",
    "href": "09_lists.html#lists",
    "title": "9  Lists",
    "section": "9.2 Lists",
    "text": "9.2 Lists\nThe object sep is a list, a class of objects that we have not yet encountered explicitly (however, data.frames are lists). Lists can simultaneously store many objects of various classes. Recall from earlier that elements of a vector were forced to be of the same class (e.g., character). Lists are much more flexible and can contain characters, vectors, matrices, data.frames, and even other lists. Let’s take a detour from our original problem of separating blood pressures in order to investigate lists.\nCreate a list containing a single number, a character, and a vector of number.\n&gt; L = list(5, \"Hi\", c(3,8,7))\n&gt; L\nThe syntax for indexing lists is different than that for vectors or matrices. If we type L[1], we obtain the sub-list containing 5 instead of just the number 5.\n&gt; L[1]\n&gt; class(L[1])\nInstead, we must use double-brackets to extract the number 5 rather than the sublist containing the number 5.\n&gt; L[[1]]\n&gt; class(L[[1]])\nThe following extracts the 8 from the third element of the list.\n&gt; L[[3]][2]\nNow that we have a basic understanding of lists. Let’s return to our problem of separating diastolic and systolic blood pressure.\n&gt; sep\n&gt; s = sep[[1]][1]\n&gt; d = sep[[1]][2]\n&gt; s\n&gt; d\n&gt; s = as.numeric(s)\n&gt; d = as.numeric(d)\n&gt; s\n&gt; d\nIt worked! Now we need to do this for every person. One way this can be accomplished is with a for loop or *apply. We will revisit this after covering programming. You can try the following but more is needed.\n&gt; strsplit(as.character(dat$bp), split=\"/\")"
  },
  {
    "objectID": "10_generalized_linear_models.html#logistic-regression",
    "href": "10_generalized_linear_models.html#logistic-regression",
    "title": "10  Generalized Linear Models (GLM)",
    "section": "10.1 Logistic Regression",
    "text": "10.1 Logistic Regression\nLogistic regression is a specific type of GLM used to model a binary outcome. If we label a success “1” and a failure “0”, the odds of success are defined as \\(P(Y=1)/P(Y=0)\\). Logistic regression models the log odds of success as a linear combination of the predictors. \\[{\\rm log}\\left(\\frac{P(Y=1|X)}{P(Y=0|X)}\\right) =  \\beta_0 + \\beta_1X_1 + ... + \\beta_pX_p\\]\nIn logistic regression, \\(\\beta_i\\) is the effect of \\(X_i\\) on the log odds of success (\\(Y=1\\)).\nFor an example, we use the “Mroz\" data in the car library. Let’s first review the”Mroz” data set.\n&gt; library(car)\n&gt; help(Mroz)\nThe syntax for glm is nearly the same as the syntax for lm. One important additional argument is family, which specifies what type of GLM will be fit. Logistic regression models a binary response, so we use the binomial family.\n&gt; mroz.mod = glm(lfp\\(\\sim\\)I(k5==0) + age + wc + hc + lwg + inc, data=Mroz,\n+   family=binomial)\n&gt; summary(mroz.mod)\nThe fitted object mroz.mod is of a new type of class.\n&gt; class(mroz.mod)\nWe can extract the estimated coefficients using coef.\n&gt; coef(mroz.mod)\nWhen reporting the effects of a logistic regression analysis, it is common to include the effect on the odds of success. Since \\(\\beta_i\\) is the effect of \\(X_i\\) on the log odds of success, \\(e^{\\beta_i}\\) is the effect of \\(X_i\\) on the odds of success[^1]. We can estimate the effects of the predictors on the odds by exponentiating the coefficients.\n&gt; exp(coef(mroz.mod))\nWe can also obtain confidence intervals for both the log odds and odds effects.\n&gt; confint(mroz.mod)\n&gt; exp(confint(mroz.mod))"
  },
  {
    "objectID": "12_programming.html#branching",
    "href": "12_programming.html#branching",
    "title": "11  Programming",
    "section": "11.1 Branching",
    "text": "11.1 Branching\nTo begin with, let’s look at an example of how if-then statements work in R. Try submitting this command at the prompt to see how it works:\n&gt; if (1&gt;0) print(\"I Like Binary\")\nNote that R prints “I Like Binary\" because the condition in the if statement is true. The print function is very useful for programming purposes, in that it prints simple strings in the R Console. No explicitly labeled then statement is needed after an if statement; you simply type what you would like R to do if the if condition is true. In general, if you want to do more than one thing if the if condition is true, you use this bracketed structure:\nif (logical condition) {\ndo this\nand this\nand this\n}\nThe statements in the brackets usually refer to function calls and object assignments, and simply need to be on separate lines (no punctuation necessary!). If necessary, you can use an “else” option:\n&gt; if (x&gt;5) print(\"x is big\") else print(\"x is small\")"
  },
  {
    "objectID": "12_programming.html#looping",
    "href": "12_programming.html#looping",
    "title": "11  Programming",
    "section": "11.2 Looping",
    "text": "11.2 Looping\nNow let’s take a look at how a “for” loop works in R. Try submitting the following syntax at the command prompt:\n&gt; for (i in 1:5) print(i)\nR prints 1, 2, 3, 4, and 5. For loops work like if conditions, and if you want R to do more than one thing in a for loop, use brackets around the commands:\nfor(i in a:b) {\ndo this\nand this\nand this\n}\nwhile and repeat loops in R work in a manner very similar to other programming languages. One or more commands are executed repeatedly while a condition remains true. Typically a counter object is initialized for controlling the loop, and then incremented within the while loop while certain commands are executed for each repetition. The loop ends when the while condition is false.\nt = 0\nwhile(t &lt; 7) {\nprint(t)\nt = t+1\n}"
  },
  {
    "objectID": "12_programming.html#blood-pressure-example-revisited",
    "href": "12_programming.html#blood-pressure-example-revisited",
    "title": "11  Programming",
    "section": "11.3 Blood Pressure Example Revisited",
    "text": "11.3 Blood Pressure Example Revisited\nEarlier we dealt with a data set where diastolic and systolic blood pressure had been read into a single column separated. We learned how to extract the two blood pressures using the strsplit function. Now that we have discussed creating functions and programming, we will separate the two measurements for the entire data set. We begin by clearing up the workspace.\n&gt; ls()\n&gt; rm(list=ls())\n&gt; dat = read.csv(\"linmod.csv\", header=TRUE, na.strings=c(\"NA\", 888, 999, \"Not Reported\"))\nExtract a blood pressure for practice.\n&gt; b = dat$bp[1]\nRecall that the following commands successfully extracted the separated measurements.\n&gt; ## Change to character.\n&gt; b = as.character(b)\n&gt; sep = strsplit(b, split=\"/\")\n&gt; ## Extract systolic blood pressure.\n&gt; s = sep[[1]][1]\n&gt; ## Extract diastolic blood pressure.\n&gt; d = sep[[1]][2]\n&gt; ## Convert to numeric.\n&gt; s = as.numeric(s)\n&gt; d = as.numeric(d)\nNow we enclose the following commands in a function. We will name this function extract.bp.\n&gt; extract.bp = function(x) {\n&gt; x = as.character(x)\n&gt; sep = strsplit(x, split=\"/\")\n&gt; s = as.numeric(sep[[1]][1])\n&gt; d = as.numeric(sep[[1]][2])\n&gt; return(c(s,d))\n&gt; }\nType extract.bp at the command line to verify the creation of the function was successful.\n&gt; extract.bp\nNow let’s experiment to see if our function works.\n&gt; b\n&gt; extract.bp(b)\nThe following code uses a loop to extract the blood pressures for each variable in the data set.\n&gt; ## Number of rows in the data set.\n&gt; n = dim(dat)[1]\n&gt; ## Set up empty numeric vectors to store two blood pressures.\n&gt; systolic = numeric(n)\n&gt; diastolic = numeric(n)\n&gt; ## Loop over the rows and extract.\n&gt; for (j in 1:n){\n&gt; out = extract.bp(dat$bp[j])\n&gt; systolic[j] = out[1]\n&gt; diastolic[j] = out[2]\n&gt; }\n&gt; systolic\n&gt; diastolic"
  },
  {
    "objectID": "12_programming.html#the-apply-function",
    "href": "12_programming.html#the-apply-function",
    "title": "11  Programming",
    "section": "11.4 The apply Function",
    "text": "11.4 The apply Function\nThe apply function performs a function on each row or column of a matrix. (There are other *apply functions for other situations.) First create a couple matrices to play with. In addition to the matrix function, rbind (or cbind) can be used to create matrices. For example,\n&gt; c1 = c(2, 9, 3)\n&gt; c2 = c(12, 1, 5)\n&gt; M2 = cbind(c1, c2)\n&gt; M2\n&gt; apply(M2, 2, mean)\nIn the example above, apply took three arguments:\n\nThe first argument, “M2” is the matrix\nThe second argument, “2”, is an index indicating the function is applied separately for each column, a value of “1” would apply the function on each row\nThe last argument is the function that is applied\n\nIf you were to just type mean(M2), the mean would be computed over the entire matrix.\n&gt; mean(M2)"
  },
  {
    "objectID": "04_basic_data_processing.html#loading-data",
    "href": "04_basic_data_processing.html#loading-data",
    "title": "4  Basic data processing",
    "section": "4.1 Loading data",
    "text": "4.1 Loading data\nOnce we know where to find data files in our computer, we can start loading them into R. Note, however, that we need specific ways to open different file formats.\n\n4.1.1 Plain text files\nPlain-text files are simple and many programs can read them. This is why many organizations (e.g., the Census Bureau, the Social Security Administration, etc.) publish their data as plain-text files.\nA plain-text file stores a table of data in a text document. Each row of the table is saved on its own line, and a simple symbol separates the cells within a row. This symbol is often a comma, but it can also be a tab, a pipe delimiter |, or any other character. Each file only uses one symbol to separate cells, which minimizes confusion.\nWe will work with data from this1 plain text file. Use Ctrl+Shift+s to download the file. Then save it in your working directory with the name “flower”.\n\n4.1.1.1 read.table\nread.table() can load plain-text files. The first argument of read.table() is the name of your file (if it is in your working directory), or the file path to your file (if it is not in your working directory).\n\nflower_df &lt;- read.table(\"data_files/flower.csv\", header = TRUE, sep = \",\")\n\nIn the code above, I added two more arguments, header and sep. header tells R whether the first line of the file contains variable names instead of values. sep tells R the symbol that the file uses to separate the cells.\nSometimes a plain-text file starts with text that is not part of the data set. Or, maybe we want to read only part of a data set. Argument skip tells R to skip a specific number of lines before it starts reading in values from the file. Argument nrow tells R to stop reading in values after it has read in a certain number of lines. Keep in mind that the header row doesn’t count towards the total rows allowed by nrow.\n\nflower_df_chunk &lt;- read.table(\n    \"data_files/flower.csv\", \n    header = TRUE, \n    sep = \",\", \n    skip = 0, \n    nrow = 3\n)\nflower_df_chunk\n\n  treat nitrogen block height weight leafarea shootarea flowers\n1   tip   medium     1    7.5   7.62     11.7      31.9       1\n2   tip   medium     1   10.7  12.14     14.1      46.0      10\n3   tip   medium     1   11.2  12.76      7.1      66.7      10\n\n\nread.table() has other arguments that you can tweak. You can consult the function’s help page to know more about it.\n\n\n4.1.1.2 Shortcuts for read.table\nR has shortcut functions that call read.table() in the background with different default values for popular types of files:\n\nread.table is the general purpose read function.\nread.csv reads comma-separated values (.csv) files.\nread.delim reads tab-delimited files.\nread.csv2 reads .csv files with European decimal format.\nread.delim2 reads tab-delimited files with European decimal format.\n\n\n\n4.1.1.3 Excel files\nThe best way to load Excel files (.xlsx) into R is not to use Excel files. Instead, save these files as .csv or .text files and then use read.table. Excel files can include multiple spreadsheets, macros, colors, dynamic tables, and other hidden, complicated formats. All of these make it difficult for R to read the files properly. Plain text files are simpler, so we can load, and transfer them more easily.\nStill, there are ways to load Excel files into R if we really need to. R has no native way of loading these files, but we can use the package readxl. If you don’t have it installed, you can type install.packages(\"readxl\"). Then\n\n\n4.1.1.4 HTML links\nread.table and its shortcuts allow us to load data files directly from a website. Instead of using the file’s path or name, we can directly use a web address in the file argument of the function. Do make sure that you are using the web address that links directly to the file, not to a web page that has a link to the file.\n\n\n4.1.1.5 read.fwf\nFixed-width file (.fwf) is a type of plain-text file that, instead of a symbol, uses its layout to separate data cells. Each row is still in a single line, and each column begins at a specific number of characters from the left-hand side of the document. To correctly position its data, the file adds an arbitrary number of character spaces between data entries.\nIf our flowers data came in a fixed-width file, the first few lines would look like this:\n\ntreat  nitrogen block  height  weight  leafarea  shootarea  flowers\ntip    medium   1      7.5     7.62    11.7      31.9       1\ntip    medium   1      10.7    12.14   14.1      46.0       10\ntip    medium   1      11.2    12.76   7.1       66.7       10\ntip    medium   1      10.4    8.78    11.9      20.3       1\ntip    medium   1      10.4    13.58   14.5      26.9       4\ntip    medium   1      9.8     10.08   12.2      72.7       9\n\nFixed-width files may be visually intuitive, but they are difficult to work with. Perhaps because of this, R has a function for reading fixed-width files, but not for saving them.\nYou can read fixed-width files into R with the function read.fwf(). This function adds another argument to the ones from read.table(): widths, which should be a vector of numbers. Each ith entry of the widths vector should state the width (in characters) of the ith column of the data set."
  },
  {
    "objectID": "04_basic_data_processing.html#cleaning-data",
    "href": "04_basic_data_processing.html#cleaning-data",
    "title": "4  Basic data processing",
    "section": "4.2 Cleaning data",
    "text": "4.2 Cleaning data\nFirst we want to make sure that the column names follow the rules we saw in section 1. This will facilitate working with different columns later.\nNow we want to ensure that every column has the right format. Let’s check the types of the columns in our current data set R.\n\n# str(flowers_df_clean)\n\nColumns INSERT NAMES HERE are of type character, which is not wrong, but it will be easier to handle them if we convert them to factors.\nNext, let’s substitute the “missing” values with\nNotice that column INSERT NAME HERE is of type character, but it has numbers there. In this case, the reason is that one value in INSERT NAME HERE has quotation marks, so R coerces the entire column to be of type character. We can fix this by doing:"
  },
  {
    "objectID": "04_basic_data_processing.html#data-summaries-and-visualizations",
    "href": "04_basic_data_processing.html#data-summaries-and-visualizations",
    "title": "4  Basic data processing",
    "section": "4.3 Data summaries and visualizations",
    "text": "4.3 Data summaries and visualizations\nNow that our data is clean, we can get more complete summaries to understand what is going on. Function summary() recognizes the type of each column and displays an intuitively appropriate summary:\n\n# summary(flower_df_clean)"
  },
  {
    "objectID": "04_basic_data_processing.html#references",
    "href": "04_basic_data_processing.html#references",
    "title": "4  Basic data processing",
    "section": "4.4 References",
    "text": "4.4 References\nMost of this section is based on “Hands-On Programming with R”, by Garret Grolemund; and on “An Introduction to R”, by Alex Douglas, Deon Roos, Francesca Mancini, Ana Couto & David Lusseau."
  },
  {
    "objectID": "04_basic_data_processing.html#footnotes",
    "href": "04_basic_data_processing.html#footnotes",
    "title": "4  Basic data processing",
    "section": "",
    "text": "You can find the original file here courtesy of Douglas et al. (see references).↩︎"
  },
  {
    "objectID": "02_getting_started_with_r.html#acquiring-external-packages",
    "href": "02_getting_started_with_r.html#acquiring-external-packages",
    "title": "2  Getting Started with R",
    "section": "2.9 Acquiring external packages",
    "text": "2.9 Acquiring external packages\nWe don’t need to reinvent the wheel every time we need to do something that is not available in R’s default version. We can easily download packages from CRAN’s online repositories to get many useful functions.\nTo install a package from CRAN, we can use the install.packages() function. For example, if we wanted to install the package readxl (for loading .xslx files), we would need:\n\ninstall.packages(\"readxl\", dependencies = TRUE)\n\nThe argument dependencies tells R whether it should also download other packages that readxl needs to work.\nR may ask you to select a CRAN mirror, which simply put refers to the location of the servers you want to download from. Choose a mirror close to where you are.\nAfter installing a package, we need to load it into R before we can use its functions. To load the package readxl, we need to use the function library(), which will also load any other packages required to load readxl and may print additional information.\n\nlibrary(\"readxl\")\n\nEvery time we start a new R session we need to load the packages we need. If we try to run a function without loading its package first, we will get an error message saying that R could not find it.\nWriting all our library() statements at the top of our R scripts is almost always a good idea. This helps us know that we need to load the libraries at the start our sessions; and it helps others know quickly that they will need to have those libraries installed to be able to use our code.\nSometimes only need one or two functions from a library. To avoid loading the entire library, we can access the specific function directly by specifying the package name followed by two colons and then the function name. For example:\n\nreadxl::read_xlsx(\"fake_data_file.xlsx\")"
  }
]